<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="Lucky-Sabrinadol">
  <!-- Open Graph Data -->
  <meta property="og:title" content="蚂蚁问题-POJ1852-P1367--思维题--详解">
  <meta property="og:description" content="She is my world">
  <meta property="og:site_name" content="Lucky&#39;s blog">
  <meta property="og:type" content="article">
  <meta property="og:image" content="https://sabrinadol.github.io">
  
    <link rel="alternate" href="/atom.xml" title="Lucky&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Lucky's blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">蚂蚁问题-POJ1852-P1367--思维题--详解</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/Sabrinadol">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<your-email-address>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Lucky-Sabrinadol</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-07-26</span>
            <span class="time">21:11:47</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/7-26-only-for-S/">#7-26 only for S.</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p><a href="http://poj.org/problem?id=1852" target="_blank" rel="noopener">POJ1852</a><br>蚂蚁<br>时间限制： 1000MS        内存限制： 30000K<br>提交总数： 31489        接受： 11801<br>描述</p>
<p>一队蚂蚁在长度为1厘米的水平杆上行走，每根杆的速度恒定为1厘米/秒。当一只行走的蚂蚁到达极的一端时，它会立即从它上掉下来。当两只蚂蚁相遇时，它们会转身并开始向相反方向行走。我们知道蚂蚁在杆子上的原始位置，不幸的是，我们不知道蚂蚁行走的方向。你的任务是计算所有蚂蚁从杆上掉下来所需的最早和最晚时间。<br>输入</p>
<p>第一行输入包含一个整数，给出后面的案例数。每种情况的数据都以两个整数开始：极点长度（cm）和n，极点上的蚂蚁数量。这两个数字之后是n个整数，它们将杆上每只蚂蚁的位置作为从杆的左端测量的距离，没有特别的顺序。所有输入整数都不大于1000000，它们由空格分隔。<br>产量</p>
<p>对于每种输入情况，输出由单个空格分隔的两个数字。第一个数字是所有蚂蚁从杆上掉下来的最早时间（如果他们的步行方向选择得恰当），第二个数字是最久可能的时间。<br>样本输入</p>
<p>2<br>10 3<br>2 6 7<br>214 7<br>11 12 7 13 176 23 191<br>样本输出</p>
<p>4 8<br>38 207<br>资源</p>
<p>滑铁卢当地人2004.09.19</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>1.<strong>算法思想</strong><br>我们·来看本题，直接对结果进行分析，是不是可以知道每个蚂蚁的最终的结果都是落了下来。其次题目中提到了，在两只蚂蚁相遇的过程中，两只蚂蚁会反向，首先我们的想法就是直接枚举，但是这样的时间复杂度显然是 2^n,不用想就要舍弃。既然是求最值，那么肯定跟贪心什么的有关系。回到蚂蚁反向的时刻，虽然蚂蚁反向了，但是两只蚂蚁的最终结果难道不都是掉下去了吗，并且两只蚂蚁并没有任何区别，那么我们可不可以看做两只蚂蚁并未反向，而是进行了灵魂交换。。。？<br>想到这里问题就很明朗了，通过贪心的策略，对于每一只蚂蚁而言，最长时间就是朝向离自己最远的一端，最近时间就是朝向离自己最近的一端。<br>直接套上一个循环然后求最值即可；<br>2.<strong>核心代码讲解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lmi=<span class="number">0</span>,lmx=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			lmi=max(lmi,min(a[i],n-a[i]));</span><br><span class="line">			<span class="comment">//动态求最小值</span></span><br><span class="line">			<span class="comment">//因为是时间，所以要满足时间最长的蚂蚁能够掉下去，所以要在原最小值和现最小值间取最大值</span></span><br><span class="line">			lmx=max(lmx,max(a[i],n-a[i]));</span><br><span class="line">			<span class="comment">//同理</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lmi&lt;&lt;<span class="string">" "</span>&lt;&lt;lmx&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>3.<strong>附上AC代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">int</span> lmi=<span class="number">0</span>,lmx=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			lmi=max(lmi,min(a[i],n-a[i]));</span><br><span class="line">			lmx=max(lmx,max(a[i],n-a[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;lmi&lt;&lt;<span class="string">" "</span>&lt;&lt;lmx&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Sabrina"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//防copy</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.org/problem/P1367" target="_blank" rel="noopener">P1367</a><br>题目描述<br>有许多蚂蚁在一根无限长的木棍上，每一只蚂蚁都有一个初始位置和初始朝向（任意两只蚂蚁的初始位置不同）。蚂蚁们以每秒一个单位的速度向前移动，当两只蚂蚁相遇时，它们会掉头（掉头时间忽略不计）。现给出每只蚂蚁的初始位置和初始朝向，请你计算出它们在t秒后的位置和朝向。</p>
<p>输入格式<br>第一行，两个空格隔开的整数n，t（代表蚂蚁数n和时间t）</p>
<p>第2~n+1行每行两个整数，第i+1行代表第i只蚂蚁的初始位置ai（ai的绝对值在1000000以内）及初始朝向bi（bi=1时蚂蚁朝右，bi=-1时蚂蚁朝左）</p>
<p>输出格式<br>n行，每行两个整数，第i行代表t秒后第i只蚂蚁的位置及朝向（-1表示朝左，1表示朝右，0表示正在转向中）</p>
<p>输入输出样例<br>输入 #1 复制<br>4 1<br>1 1<br>5 1<br>3 -1<br>10 1<br>输出 #1 复制<br>2 0<br>6 1<br>2 0<br>11 1<br>说明/提示<br>【数据范围】</p>
<p>对于40%的数据，n&lt;=100</p>
<p>对于80%的数据，n&lt;=10000,t&lt;=1000</p>
<p>对于100%的数据，n&lt;=100000,t&lt;=100000</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>1.<strong>算法思想</strong><br>此题相对而言就要稍微复杂一些，可以称其为升级版。</p>
<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>看到本题，很明显，经过上一道题的练习，我们很容易想到只管初末状态，在更换灵魂的时候只需要换一下数组下标，最后直接输出就好</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>1.<br>因为关于一个下标，我们有两个数据（方向，位置）来存储，所以显然需要开一个结构体。<br>其次，因为要把时间复杂度控制在线性上面，所以显然需要预处理，也就是按输入的位置来排序<br>2.<br>其次，我们需要另开一个结构体数组来存贮之后的状态<br>3.<br>在对下标的处理中，我们需要另开一个数组来改变下标对蚂蚁的映射关系，使输出的序列满足从小到大<br>4.可能有人还比较模糊，看代码<br>5.附上AC代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> s;<span class="comment">//存位置</span></span><br><span class="line">	<span class="keyword">int</span> h;<span class="comment">//存方向</span></span><br><span class="line">	<span class="keyword">int</span> num;<span class="comment">//存下标</span></span><br><span class="line">&#125;q[maxn],p[maxn];<span class="comment">//q用来保存初状态，p用来保存末状态</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.s&lt;y.s;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="keyword">int</span> a,b;	</span><br><span class="line"><span class="keyword">int</span> order[maxn];<span class="comment">//改变的映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		q[i].s=a;</span><br><span class="line">		q[i].h=b;</span><br><span class="line">		q[i].num=i;</span><br><span class="line">		p[i].s=a+b*t;<span class="comment">//t的正负代表了向右还是向左</span></span><br><span class="line">		p[i].num=<span class="number">0</span>;<span class="comment">//对于p数组是用来通过order的映射输出的所以不需要</span></span><br><span class="line">		p[i].h=b;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(q+<span class="number">1</span>,q+<span class="number">1</span>+n,cmp);<span class="comment">//预处理</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		order[q[i].num]=i;<span class="comment">//从左到右的蚂蚁编号映射成现在sort后对应的下标</span></span><br><span class="line">	&#125;</span><br><span class="line">	sort(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp);<span class="comment">//同样，将蚂蚁按从左到右排列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[i].s==p[i+<span class="number">1</span>].s)<span class="comment">//这个是用来考虑判断是否正在经历相遇转向的过程</span></span><br><span class="line">		&#123;</span><br><span class="line">			p[i].h=<span class="number">0</span>;</span><br><span class="line">			p[i+<span class="number">1</span>].h=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> g=order[i];</span><br><span class="line">		<span class="comment">//再通过映射关系，获得根据输入数据而获得的标号，实现相遇时的反向，交换，下面有一波打表</span></span><br><span class="line">		<span class="comment">//大概就是说第i个输入的数现在在第几个位置上 </span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;p[g].s&lt;&lt;<span class="string">" "</span>&lt;&lt;p[g].h&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code class="c">n=<span class="number">3</span>； t=<span class="number">2</span>；
q[<span class="number">1</span>].s=<span class="number">3</span>;q[<span class="number">1</span>].num=<span class="number">1</span>;q[<span class="number">1</span>].h=<span class="number">-1</span>;
q[<span class="number">2</span>].s=<span class="number">2</span>;q[<span class="number">2</span>].num=<span class="number">2</span>;q[<span class="number">1</span>].h=<span class="number">1</span>;
q[<span class="number">3</span>].s=<span class="number">1</span>;q[<span class="number">3</span>].num=<span class="number">3</span>;q[<span class="number">3</span>].h=<span class="number">1</span>;
p[<span class="number">1</span>].s=<span class="number">1</span>;p[<span class="number">1</span>].h=<span class="number">-1</span>;
p[<span class="number">2</span>].s=<span class="number">4</span>;p[<span class="number">2</span>].h=<span class="number">1</span>;
p[<span class="number">3</span>].s=<span class="number">3</span>;p[<span class="number">3</span>].h=<span class="number">1</span>;
sort1:
q[<span class="number">1</span>].num=<span class="number">3</span>;q[<span class="number">2</span>].num=<span class="number">2</span>;q[<span class="number">3</span>].num=<span class="number">1</span>;

order[<span class="number">1</span>]=<span class="number">3</span>;order[<span class="number">2</span>]=<span class="number">2</span>;order[<span class="number">3</span>]=<span class="number">1</span>;

sort2:
p[<span class="number">1</span>].s=<span class="number">1</span>;p[<span class="number">2</span>].s=<span class="number">3</span>;p[<span class="number">3</span>].s=<span class="number">4</span>;

<span class="keyword">for</span>:
i=<span class="number">1</span>:g=<span class="number">3</span>;
i=<span class="number">2</span>:g=<span class="number">2</span>;
i=<span class="number">3</span>:g=<span class="number">1</span>;


</code></pre>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

