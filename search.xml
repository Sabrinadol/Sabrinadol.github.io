<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DPlearning]]></title>
    <url>%2F2019%2F08%2F13%2FDPlearning%2F</url>
    <content type="text"><![CDATA[1-Conclusion–dp1.一般来讲dp就分为三种：区间dp ，状态压缩dp ，树上dp 2.其实个人觉得dp的题代码都是比较好写的，最重要的就是要找到状态转移方程 3.三种dp中区间dp是最常见也是最重要的，状态压缩在压缩上的实现可能需要一点位运算什么的，树形dp简单一点。 2-区间dp–P1880环状石子合并题解传送门题目描述在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分. 输入格式数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数. 输出格式输出共2行,第1行为最小得分,第2行为最大得分. 输入输出样例输入 #1 复制44 5 9 4输出 #1 复制4354 ##题解##1.题目要求求区间内的最大值以及最小值，很明显就需要通过子区间的状态传递来实现动规操作了。2.本题有一个很重要的点。就是该数据是呈环状的。也就是说我们dp得到的答案是这样的： dp[i][i+n-1]。且1&lt;=i&lt;=n。而并不是一般dp的：dp[1][n];那这个问题怎么解决呢？goodquestion。直接将我们的dp边界扩大一倍。拆环成链。3.dp方程其实很简单。在我们的区间i，j中枚举一个k来求得最小/最大值b数组装得是前缀和 12dp1[i][j]=min(dp1[i][j],dp1[i][k]+dp1[k+1][j]+b[j]-b[i-1]);dp2[i][j]=max(dp2[i][j],dp2[i][k]+dp2[k+1][j]+b[j]-b[i-1]); 4.附上AC代码+注释、 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #define maxn 205 using namespace std;int dp1[maxn][maxn];int dp2[maxn][maxn];int a[305];int b[305]; int n;const int inf = 1e9;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; a[n+i]=a[i];//拆环成链 &#125; for(int i=1;i&lt;=n*2;i++) &#123; b[i]=b[i-1]+a[i];// &#125; for(int l=2;l&lt;=n;l++)//区间长度 &#123; for(int i=1,j;(j=i+l-1)&lt;=2*n;i++)// 因为是环所以边界为2*n &#123; dp1[i][j]=999999999; for(int k=i;k&lt;j;k++) &#123; dp1[i][j]=min(dp1[i][j],dp1[i][k]+dp1[k+1][j]+b[j]-b[i-1]); dp2[i][j]=max(dp2[i][j],dp2[i][k]+dp2[k+1][j]+b[j]-b[i-1]); &#125; &#125; &#125; int f1=1e9+1; int f2=-10; for(int i=1;i&lt;=n;i++) &#123; f1=min(dp1[i][i+n-1],f1); f2=max(dp2[i][i+n-1],f2); &#125; cout&lt;&lt;f1&lt;&lt;endl&lt;&lt;f2; return 0;&#125; 区间dp–P1220关路灯传送门题目描述某一村庄在一条路线上安装了n盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。 为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。 现在已知老张走的速度为1m/s，每个路灯的位置（是一个整数，即距路线起点的距离，单位：m）、功率（W），老张关灯所用的时间很短而可以忽略不计。 请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。 输入格式文件第一行是两个数字n(1&lt;=n&lt;=50，表示路灯的总数)和c(1&lt;＝c&lt;=n老张所处位置的路灯号)； 接下来n行，每行两个数据，表示第1盏到第n盏路灯的位置和功率。数据保证路灯位置单调递增。 输出格式一个数据，即最少的功耗(单位：J，1J＝1W·s)。 输入输出样例输入 #1 复制5 32 103 205 206 308 10输出 #1 复制270说明/提示输出解释： {此时关灯顺序为3 4 2 1 5，不必输出这个关灯顺序} 题解1.对于本题策略应该是很清楚的。看到求区间最值时候就很容易想到dp2.（1）对于本题我们需要一个dp数组dp[i][j]表示从关掉i到j中间的所有路灯的最小值（2）在对区间答案进行求解的时候，因为对于这个区间而言，如果关灯者在左边还是在右边情况是不同的。因为他区间是有长度的，他从左边运动到右边需要花时间。我们就只需要在dp数组上加一维度来表示在左边还是右边。（3）动态转移方程其实是很简单的，就是简单的运用一下区间dp的知识就好了 123456789101112f[i][j][0]=min( f[i+1][j][0]+(s[i+1]-s[i])*(p[n]-p[j]+p[i]), //s[i]表示编号为i的路灯的坐标 //p数组是一个功率的前缀和，使用前缀和比较方便 f[i+1][j][1]+(s[j]-s[i])*(p[n]-p[j]+p[i]));f[i][j][1]=min( f[i][j-1][1]+(s[j]-s[j-1])*(p[n]-p[j-1]+p[i-1]), f[i][j-1][0]+(s[j]-s[i])*(p[n]-p[j-1]+p[i-1])); 3.附上AC代码+注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #define ll long long int #define maxn 105using namespace std;int n,c;int b[maxn];int s[maxn];int p[maxn];int f[maxn][maxn][5];int main()&#123; memset(f,127,sizeof(f)); scanf("%d%d",&amp;n,&amp;c); f[c][c][0]=f[c][c][1]=0;//瞬间被关 for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",s+i,b+i); p[i]=p[i-1]+b[i]; &#125; for(int l=2;l&lt;=n;l++) &#123; for(int i=1,j;(j=i+l-1)&lt;=n;i++) &#123; if(i&lt;=c&amp;&amp;c&lt;=j)//如果不满足人在区间内显然不满足 &#123; f[i][j][0]=min ( f[i+1][j][0]+(s[i+1]-s[i])*(p[n]-p[j]+p[i]), f[i+1][j][1]+(s[j]-s[i])*(p[n]-p[j]+p[i]) ); f[i][j][1]=min ( f[i][j-1][1]+(s[j]-s[j-1])*(p[n]-p[j-1]+p[i-1]), f[i][j-1][0]+(s[j]-s[i])*(p[n]-p[j-1]+p[i-1]) ); &#125; &#125; &#125; cout&lt;&lt;min(f[1][n][0],f[1][n][1]); return 0;&#125; 区间dp–P4170 [CQOI2007]涂色传送门题目描述假设你有一条长度为5的木版，初始时没有涂过任何颜色。你希望把它的5个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为5的字符串表示这个目标：RGBGR。 每次你可以把一段连续的木版涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木版涂成RRRRR，第二次涂成RGGGR，第三次涂成RGBGR，达到目标。 用尽量少的涂色次数达到目标。 输入格式输入仅一行，包含一个长度为n的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。 输出格式仅一行，包含一个数，即最少的涂色次数。 输入输出样例输入 #1 复制AAAAA输出 #1 复制1输入 #2 复制RGBGR输出 #2 复制3说明/提示40%的数据满足：1&lt;=n&lt;=10 100%的数据满足：1&lt;=n&lt;=50 题解1.本题题意：区间内的涂色次数。这很明显！–区间dp。状态很好定义，就是f[i][j]表示从i到j的涂色次数。2.需要注意的是，本题要求的是最优解，但是涂色是以区间的形式，那么如果区间两端要求涂的颜色相同，就可以直接从两个子区间转移过来。如下 12345if(vi[i]==vi[j])&#123; f[i][j]=min(f[i][j],f[i+1][j]); f[i][j]=min(f[i][j],f[i][j-1]); &#125; 3.初始化每个区间长度为1的区间最小值都应该是14.状态转移方程，直接在i到j之间枚举一个k就行： 1234for(int k=i;k&lt;j;k++)&#123; f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);&#125; 5.附上AC代码+注释 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; #define maxn 105using namespace std;char vi[maxn];int len=0;int f[maxn][maxn];int main()&#123; cin&gt;&gt;vi; len=strlen(vi); memset(f,0x3f,sizeof(f)); for(int i=0;i&lt;len;i++) f[i][i]=1;//初始化 for(int l=2;l&lt;=len;l++)//区间长度 for(int i=0,j;(j=i+l-1)&lt;len;i++) &#123; if(vi[i]==vi[j]) &#123; f[i][j]=min(f[i][j],f[i+1][j]); f[i][j]=min(f[i][j],f[i][j-1]); &#125; else &#123; for(int k=i;k&lt;j;k++) &#123; f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]); &#125; &#125; &#125; cout&lt;&lt;f[0][len-1]; return 0;&#125; 区间dp–P3205 [HNOI2010]合唱队传送门题目描述为了在即将到来的晚会上有更好的演出效果，作为AAA合唱队负责人的小A需要将合唱队的人根据他们的身高排出一个队形。假定合唱队一共N个人，第i个人的身高为Hi米(1000&lt;=Hi&lt;=2000),并已知任何两个人的身高都不同。假定最终排出的队形是A 个人站成一排，为了简化问题，小A想出了如下排队的方式：他让所有的人先按任意顺序站成一个初始队形，然后从左到右按以下原则依次将每个人插入最终棑排出的队形中： -第一个人直接插入空的当前队形中。 -对从第二个人开始的每个人，如果他比前面那个人高(H较大)，那么将他插入当前队形的最右边。如果他比前面那个人矮(H较小)，那么将他插入当前队形的最左边。 当N个人全部插入当前队形后便获得最终排出的队形。 例如，有6个人站成一个初始队形，身高依次为1850、1900、1700、1650、1800和1750, 那么小A会按以下步骤获得最终排出的队形： 1850 1850 , 1900 因为 1900 &gt; 1850 1700, 1850, 1900 因为 1700 &lt; 1900 1650 . 1700, 1850, 1900 因为 1650 &lt; 1700 1650 , 1700, 1850, 1900, 1800 因为 1800 &gt; 1650 1750， 1650, 1700，1850, 1900, 1800 因为 1750 &lt; 1800 因此，最终排出的队形是 1750，1650，1700，1850, 1900，1800 小A心中有一个理想队形，他想知道多少种初始队形可以获得理想的队形 输入格式无 输出格式注意要mod19650827 输入输出样例输入 #1 复制41701 1702 1703 1704输出 #1 复制8说明/提示30%的数据：n&lt;=100100%的数据：n&lt;=1000 题解1.区间求解，确定区间dp策略2.该题同样需要注意区间的左右3.状态转移+讲解：f[i][j][0/1]0/1表示左右，状态定义：从i到j的方案数如 f[i][j][0]:就是指当前插入的人在左边时 区间i 到 j的方案数 1234f[i][j][0]=f[i+1][j][0]*(h[i]&lt;h[i+1])%mod+f[i+1][j][1]*(h[i]&lt;h[j])%mod;//在从子区间进行转移时候，需要通过身高来判断是否可以进行转移//括号就相当于进行了一次逻辑运算f[i][j][1]=f[i][j-1][0]*(h[j]&gt;h[i])%mod+f[i][j-1][1]*(h[j]&gt;h[j-1])%mod; 初始化： 123memset(f,0,sizeof(f));//每个区间先初始化为零for(int i=1;i&lt;=n;i++) f[i][i][0]=1;//默认每个人都先站在左边 4.附上AC代码+注释 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define maxn 1005using namespace std;const int mod = 19650827;int f[maxn][maxn][2];int n;int h[maxn];int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) scanf("%d",h[i]); for(int i=1;i&lt;=n;i++) f[i][i][0]=1; for(int l=2;l&lt;=n;l++)//区间长度 &#123; for(int i=1,j;(j=i+l-1)&lt;=n;i++) &#123; f[i][j][0]=f[i+1][j][0]*(h[i]&lt;h[i+1])%mod+f[i+1][j][1]*(h[i]&lt;h[j])%mod; f[i][j][1]=f[i][j-1][0]*(h[j]&gt;h[i])%mod+f[i][j-1][1]*(h[j]&gt;h[j-1])%mod; &#125; &#125; cout&lt;&lt;(f[1][n][0]+f[1][n][1])%mod; return 0;&#125;]]></content>
      <tags>
        <tag>only for her</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[课题--细析费马小定理--ZOJ3785，P2842]]></title>
    <url>%2F2019%2F07%2F28%2F%E8%AF%BE%E9%A2%98-%E7%BB%86%E6%9E%90%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86-%E4%BB%8E%E6%87%82%E5%88%B0%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[0.写在前面在学习费马小定理之前，需要掌握一些数论基本知识 (0).≡-这个符号指的是左右两边的数对p求模结果相同。这里不需要太过纠结，就当做有特殊意义的等号吧。 （1）.同余同余就是指 当 c能够整除（a-b） 时，我们就称 a,b关于模 c同余 记作： （a-b）≡0（mod c）,a≡b(mod c)-补充几个性质（仅作积累，在费马小定理作用不大）当 a≡ b（mod x） c≡ d (mod x)时;满足：1.(a+c)≡ (b+d)(mod x);2.ac≡bd(mod x);3.a-c≡ (b-d)(mod x); (2).逆元（解决数论中的除法）补充 ：数论中的加减乘（a+b）%c=(a%c+b%c)%c; (a-b)%c=(a%c-b%c)%c;ab%c=(a%cb%c)%c;假如题目中数据过大就可以步步取模防止溢出记得以前数学学习中的倒数吗。一个数除以另一个数，就相当于乘以这个数的倒数。在数论中：在取模的情况下，如果要求两个数相除，那么有有可能出现小数。这个时候我们就需要引入一个乘法逆元的概念： 当a*b≡ 1（mod p）时，我们就称 b是 a关于模p的逆元##注意##：（1）当p是一个素数时，则每个数都有唯一的确定的逆元。（2）当 a是b的逆元时，b也是a的逆元（3）0没有逆元（就像0没有倒数一样） 举例 当 p=5，a=2时； b=3； （3）筛法求素数（因为费马小定理的性质，所以判定是否为素数是必备的技能）-1.求素数用到的方法（1）普通枚举 枚举到sqrt（n）就好（2）朴素筛法通过对每个数有无非平凡因子来判断朴素筛法 nlogn ，这个时间复杂度的计算有些复杂如下n/2+n/3+n/4+…..+n/n;n(1/2+1/3+1/4+….+1/n)后面那一坨大致就约等于 ln（n） （学过数竞应该知道） 12345678910111213int a[maxn],b[maxn],n;int cnt=0;//筛出 2 到 n 中的所有素数 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//从i+i往后筛所有的倍数 a[j]=1; &#125;&#125; （3）埃式筛法通过素因子来筛 123456789101112131415int a[maxn],b[maxn],n;int cnt=0;//优化， nloglogn ，这里的计算跟上个差不多，埃式筛法 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) &#123; b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//将此循环体拿到if依据里面 //意思就是，在遍历筛的时候遇到的如果是合数就不用筛了，优化 a[j]=1; &#125; &#125;&#125; （4）线性筛（欧拉筛） 123456789101112131415void oula_sieve(int n)&#123; int cnt=0; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=a[i]; for(int j=0;b[j]*i&lt;=n;j++) &#123; a[b[j]*i]=1;// 保证b[j]是i*b[j]1的最小素因子 if(i%b[j]==0) break; &#125; &#125;&#125; 大家可能对以上三种方法及其优化思路还有疑问，下面加深讲解1.基本思想其实都是先筛掉有非平凡因数的合数筛掉，再进行存储2.举下面 一个栗子比如说我们要筛 12这个数（1）朴素筛 ： 除1外每个数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 ： 2 3 4 6（2）埃氏筛 ： 除1外每个质因数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 : 2 3 （3）欧拉筛 ：可能有人不太懂1–j代表的是下标2–b[]存储找到的素数代码中的第二重（if依据巧妙避开求重）可以让标记只让当前找到的素因数往后标记3–还是举12的例子12的最小质因数会将12筛出也就是只有：2 4–总结欧拉筛： 每次用已筛出来的质数去筛更大的数，每个合数只被它最小的质因子筛掉，试想，如果26筛了12之后还没break，而是用36筛掉18，那么18还会被29筛一次，就重复了而根本原因就是6有2这个因子，而36筛掉的数一定也有2这个因子，3*6这个数应该被2这个因子筛掉，而不是3 4.最大公约数–gcd（学会gcd是费马小定理前提）gcd（a，b）指的是a，的最大公约数如果a，b互质那么 gcd（a，b）=1；一般来讲我们求gcd是通过辗转相除法的就是 gcd(a,b)=gcd(a,b%a);满足a&gt;b这里直接套一个递归就好了 123456789101112int gcd(int a,int b)&#123; return b == 0 ? a : gcd(b,a % b);&#125;//这个玩意可以这么读：b == 0否?b == 0的话返回a,b != 0的话返回gcd(b,a%b)//就是辗转相除，除到0了那么上一个除数就是最大公约数int gcd(int a,int b)&#123; if(b==0) return a; return (b,a%b);&#125; 1.费马小定理（1）.内容：-同余式写法：当 gcd（p，a）=1 ，p是一个质数时；a^p − 1 =1(mod p);当a不能被素数p整除时，(a^p-1 )- 1一定能被p整除; (2).证明在各种证明方法中，同余的方法最为简单 （1）.特殊举例证明 任意取一个质数，比如13。考虑从1到12的一系列整数1,2,3,4,5,6,7,8,9,10,11,12，给这些数都乘上一个与13互质的数，比如3，得到3,6,9,12,15,18,21,24,27,30,33,36。对于模13来说，这些数同余于3,6,9,12,2,5,8,11,1,4,7,10。这些余数实际上就是原来的1,2,3,4,5,6,7,8,9,10,11,12，只是顺序不同而已。 把1,2,3,„,12统统乘起来，乘积就是12的阶乘12！。把3,6,9,„,36也统统乘起来，并且提出公因子3，乘积就是312×12！。对于模13来说，这两个乘积都同余于1,2,3,„,12系列，尽管顺序不是一一对应，即312×12！≡12！mod 13。两边同时除以12！得312≡1 mod 13。如果用p代替13，用x代替3，就得到费马小定理。 （2）一般化证明 取素数p，以及数列{ a，2a,3a,…………….,(p-1)a}； 这个数列中所有元素模p可以取遍1到p-1之间的所有数对于此句话的证明 反证法： 如果不满足，那么必有 k1a(mod p)=k2a(mod p)，并且满足1=&lt;k1&lt;=k2&lt;=p-1; 由此可得 (k1a-k2a)=0(mod p) 又因为 gcd（a,p）=1,所以k1-k2=0(mod p),再看范围，很明显错误 证毕 我们把数列中每个元素都乘起来，得到以下式子 a1a2a*3……a*(p-1)≡(p-1）!(mod p); 约掉（p-1）！ 就可以得到 a^p − 1 =1(mod p); (3).运用1.简单举例如果现在我们要去求 2^100（mod 13）=？很明显该数过大，不过我们首先可以考虑用二分的思想，一层一层取模运算。但是有没有更好的办法呢？肯定是有的从费马小定理出发，我们是否可以将这个一百化为 n*（p-1）+k，n直接用100/12向下取整就好了，这样的话，我们就直接考虑 2^4(mod 13)=? 2.快速求逆元我们对原式进行处理(a^p-2)*a=1(mod p);根据我们对逆元的定义，是否 a^p-2就是a关于p的逆元这里的求解，因为一般题目中的数据都是较大的，所以需要快速幂 补充一段快速幂算法代码 123456789101112131415161718192021222324int rapidmi(int x, int y)&#123; int result = 1; // 定义变量 while (y &gt; 0) // 当指数大于 0 时进行幂运算 &#123; if (y &amp; 1) // y 和 1 做与运算,相当于对 2 求模 &#123; result = result * x; // 如果 y 为奇数,则结果成一个 x &#125; x = x * x; // x 乘二次方,下次使用 y = y &gt;&gt; 1; // y 右移一位,相当于除以 2 &#125; return result; // 返回结果 &#125;int main()&#123; int x, y； while (scanf("%d %d", &amp;x, &amp;y)) &#123; printf("%d ^ %d = %d\n", x, y, rapidmi(x, y)); &#125; return 0;&#125; 给出一般用费马小定理求逆元(P3381会超时3个点)题目：输入 n,m;求出 n在模m意义下的逆元 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define maxn 3000003#define ll long long int using namespace std;int n,m;ll rapid(ll a,ll b)&#123; ll result=1; while(b&gt;0) &#123; if(b&amp;1)//相当取2的模 &#123; result=result*a; &#125; a*=a; b/=2; &#125; return result;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;rapid(n,m-2);//根据定义，就应该是 n的m-2次方 return 0;&#125; 3.两道列题ZOJ3785传送门 ZOJ3785题面来自谷歌翻译今天星期六，S.和L.一起出去游玩，突然S.提出一个问题1^1 + 2^2 + 3^3 + … + N^N天后的哪一天？L.一下子就解答了，你能吗？输入有多个测试用例。 第一行输入包含一个整数T，表示测试用例的数量。 对于每个测试用例： 只有一行包含一个整数N（1 &lt;= N &lt;= 1000000000）。 产量对于每个测试用例，输出一个表示星期几的字符串。 样本输入212样本输出SundayThursday暗示一周包括周日，周一，周二，周三，周四，周五和周六。Jīntiān xīngqíliù,11 + 22 + 33 +… + NN tiānhòu de nǎ yītiān? Shūrùyǒu duō gè cèshì yònglì. Dì yīxíng shūrù bāohán yīgè zhěngshù T, biǎoshì cèshì yònglì de shùliàng. Duìyú měi gè cèshì yònglì: Zhǐyǒu yī xíng bāohán yīgè zhěngshù N(1 &lt;= N &lt;= 1000000000). Chǎnliàngduìyú měi gè cèshì yònglì, shūchū yīgè biǎoshì xīngqí jǐ de zìfú chuàn. Yàngběn shūrù212yàngběn shūchūxīngqírìxīngqísìànshìyīzhōu bāokuò zhōu rì, zhōuyī, zhōu’èr, zhōusān, zhōu sì, zhōu wǔ hé zhōu liù. 题解Sabrina看到这道题有点感觉有点难了但是一旁的同学笑了笑，这是一道非常水的题，用上费马小定理秒杀哦！ 我们知道n^n%7= (n%7)^ n%7,令n%7=m，就相当于n-7[n/7]则原式=(m^ m%7)(m^ (n-m)%7)%7举个例子，9 ^9%7=2 ^9%7=((2 ^2%7)*(2 ^7%7)) %7，所以只要让(2 ^7%7)这个部分等于1，而且这一部分，2的幂肯定是7的倍数，那么循环节就出现了，循环节的开端为m ^m%7(m&lt;7)。我们知道(2 ^a%7) ^b%7=x ^ab%7，让该公式为1，且ab为7的倍数，则a等于6（费马小定理），得ab的最小值为42，也就是要重复就经过了42种情况，所以n^n%7的循环节为42 294=42*7,即为11 + 22 + 33 + … + NN %7的循环节但是Sabrina还是有一点疑惑，于是有了下面几张图 12345678910这个题中我们的p也就是一周的天数7，最开始的形式：1^1 2^2 3^3 4^4 5^5 6^6 7^78^8 9^9 10^10 11^11 12^12 13^13 14^1415^15 16^16 17^17 18^18 19^19 20^20 21^2122^22 23^23 24^24 25^25 26^26 27^27 28^2829^29 30^30 31^31 32^32 33^33 34^34 35^3536^36 37^37 38^38 39^39 40^40 41^41 42^4243^43 44^44 45^45 46^46 47^47 48^48 49^49 这里就相当于n-7*[n/7]的过程 费马小定理转化后–&gt;&gt;（分别取6的模，然后来减掉）1^1 2^2 3^3 4^4 5^5 6^0 0^11^2 2^3 3^4 4^5 5^0 6^1 0^21^3 2^4 3^5 4^0 5^1 6^2 0^31^4 2^5 3^0 4^1 5^2 6^3 0^41^5 2^0 3^1 4^2 5^3 6^4 0^51^0 2^1 3^2 4^3 5^4 6^5 0^01^1 2^2 3^3 4^4 5^5 6^0 0^1最后一行重复，循环节长度为42 （2）P2842 LJJ算数-传送门 题目描述LJJ刚上完了一节课！这节课是数学课！他知道了加减属于一级运算，乘除属于二级运算，幂则属于三级运算，而幂的优先级&gt;乘除的优先级&gt;加减的优先级（这是几年级的数学课）。但是，从上一套试卷+上一题中，我们知道了LJJ是一个总是突发奇想并且智商不够的人（也就是说他又想出一个问题给你咯）。他发明了一种四级运算，我们姑且用符号#来表示（找不到别的符号了）。我们知道ab=a+a+a+…+a(加b次)，a^b=aaaa…a(乘b次)，则a#b=a^a^a^a^…^a(进行幂运算b次)，自然，#的优先级比幂的优先级高。那么，LJJ就请你来帮他求a#b mod 1000000007咯。（PS:这是本试卷最简单的一道题） 输入格式输入仅1行，即a,b。 输出格式输出仅1行，即a#b mod 1000000007。 输入输出样例输入 #1 复制3 5输出 #1 复制968803245说明/提示首先说明，样例答案不mod其实是4.4342648824303776994824963061915e+38（来自出题人的恶意） 然后，数据范围： 对于20%的数据，a&lt;=1000,b&lt;=1000 对于50%的数据，a&lt;=10^16,b&lt;=10000 对于100%的数据，a&lt;=10^16,b&lt;=10^16 （1）.算法分析-本题的意思就是指 求 a的b幂次方也就是 （a） ^(a)^…将此式简化得到 a ^ (a) ^ (b-1)那么到了这个时候很明显就需要分两步来求解，一部分是 a ^ (b-1) 另一部分则是求 a^ (k)为了方便设 k=a ^ (b-1)； 1–第一部分的求解，因为b-1次方仍然过大，可以进一步取模根据费马小定理可以得到a ^ m (mod p)=a ^(m mod p-1 ) (mod p） 证明： a ^ m% p= a ^ (n(p-1) a^(m%(p-1))%p(次数相加，n指的是m/p-1向下取整)由费马小定理可以得到： a^ (n*(p-1))%p==1;所以： a^ m%p= a^(m%(p-1))%p;这里就是把 a^b-1看做m就好了证毕 2–第二部分：直接用第一部分的值，上快速幂就好 3–注意点，我们在快速幂的函数，要小心代表模大小的参数，因为，由式子可知，第一次是取得 q-1第二次取的是 q； （2）附上AC代码123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define maxn 3000003using namespace std;long long int n,m;const long long int modl = 1000000007;long long int rapidmi(long long int x,long long int y,long long int z)&#123; long long int result = 1; // 定义变量 x%=z; while (y &gt; 0) // 当指数大于 0 时进行幂运算 &#123; if (y &amp; 1) // y 和 1 做与运算,相当于对 2 求模 &#123; result = result * x%z; // 如果 y 为奇数,则结果成一个 x &#125; x = x * x%z; // x 乘二次方,下次使用 y = y &gt;&gt; 1; // y 右移一位,相当于除以 2 &#125; return result; // 返回结果 &#125;int main()&#123; int x, y; cin&gt;&gt;n&gt;&gt;m; long long int k=rapidmi(n,m-1,modl-1); long long int yo=rapidmi(n,k,modl); cout&lt;&lt;yo&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>NOIPLearning</category>
      </categories>
      <tags>
        <tag>2019课题 only for her</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题-POJ1852-P1367--思维题--详解]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%9A%82%E8%9A%81%E9%97%AE%E9%A2%98-POJ1852-P1367-%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[POJ1852蚂蚁时间限制： 1000MS 内存限制： 30000K提交总数： 31489 接受： 11801描述 一队蚂蚁在长度为1厘米的水平杆上行走，每根杆的速度恒定为1厘米/秒。当一只行走的蚂蚁到达极的一端时，它会立即从它上掉下来。当两只蚂蚁相遇时，它们会转身并开始向相反方向行走。我们知道蚂蚁在杆子上的原始位置，不幸的是，我们不知道蚂蚁行走的方向。你的任务是计算所有蚂蚁从杆上掉下来所需的最早和最晚时间。输入 第一行输入包含一个整数，给出后面的案例数。每种情况的数据都以两个整数开始：极点长度（cm）和n，极点上的蚂蚁数量。这两个数字之后是n个整数，它们将杆上每只蚂蚁的位置作为从杆的左端测量的距离，没有特别的顺序。所有输入整数都不大于1000000，它们由空格分隔。产量 对于每种输入情况，输出由单个空格分隔的两个数字。第一个数字是所有蚂蚁从杆上掉下来的最早时间（如果他们的步行方向选择得恰当），第二个数字是最久可能的时间。样本输入 210 32 6 7214 711 12 7 13 176 23 191样本输出 4 838 207资源 滑铁卢当地人2004.09.19 题解1.算法思想我们·来看本题，直接对结果进行分析，是不是可以知道每个蚂蚁的最终的结果都是落了下来。其次题目中提到了，在两只蚂蚁相遇的过程中，两只蚂蚁会反向，首先我们的想法就是直接枚举，但是这样的时间复杂度显然是 2^n,不用想就要舍弃。既然是求最值，那么肯定跟贪心什么的有关系。回到蚂蚁反向的时刻，虽然蚂蚁反向了，但是两只蚂蚁的最终结果难道不都是掉下去了吗，并且两只蚂蚁并没有任何区别，那么我们可不可以看做两只蚂蚁并未反向，而是进行了灵魂交换。。。？想到这里问题就很明朗了，通过贪心的策略，对于每一只蚂蚁而言，最长时间就是朝向离自己最远的一端，最近时间就是朝向离自己最近的一端。直接套上一个循环然后求最值即可；2.核心代码讲解 12345678910int lmi=0,lmx=0; for(int i=1;i&lt;=m;i++) &#123; lmi=max(lmi,min(a[i],n-a[i])); //动态求最小值 //因为是时间，所以要满足时间最长的蚂蚁能够掉下去，所以要在原最小值和现最小值间取最大值 lmx=max(lmx,max(a[i],n-a[i])); //同理 &#125; cout&lt;&lt;lmi&lt;&lt;" "&lt;&lt;lmx&lt;&lt;endl; 3.附上AC代码 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define maxn 1000005using namespace std;int t;int a[maxn];int n,m; int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) cin&gt;&gt;a[i]; int lmi=0,lmx=0; for(int i=1;i&lt;=m;i++) &#123; lmi=max(lmi,min(a[i],n-a[i])); lmx=max(lmx,max(a[i],n-a[i])); &#125; cout&lt;&lt;lmi&lt;&lt;" "&lt;&lt;lmx&lt;&lt;endl; &#125; while(1) cout&lt;&lt;"Sabrina"&lt;&lt;endl;//防copy return 0;&#125; P1367题目描述有许多蚂蚁在一根无限长的木棍上，每一只蚂蚁都有一个初始位置和初始朝向（任意两只蚂蚁的初始位置不同）。蚂蚁们以每秒一个单位的速度向前移动，当两只蚂蚁相遇时，它们会掉头（掉头时间忽略不计）。现给出每只蚂蚁的初始位置和初始朝向，请你计算出它们在t秒后的位置和朝向。 输入格式第一行，两个空格隔开的整数n，t（代表蚂蚁数n和时间t） 第2~n+1行每行两个整数，第i+1行代表第i只蚂蚁的初始位置ai（ai的绝对值在1000000以内）及初始朝向bi（bi=1时蚂蚁朝右，bi=-1时蚂蚁朝左） 输出格式n行，每行两个整数，第i行代表t秒后第i只蚂蚁的位置及朝向（-1表示朝左，1表示朝右，0表示正在转向中） 输入输出样例输入 #1 复制4 11 15 13 -110 1输出 #1 复制2 06 12 011 1说明/提示【数据范围】 对于40%的数据，n&lt;=100 对于80%的数据，n&lt;=10000,t&lt;=1000 对于100%的数据，n&lt;=100000,t&lt;=100000 题解1.算法思想此题相对而言就要稍微复杂一些，可以称其为升级版。 整体思路看到本题，很明显，经过上一道题的练习，我们很容易想到只管初末状态，在更换灵魂的时候只需要换一下数组下标，最后直接输出就好 具体实现1.因为关于一个下标，我们有两个数据（方向，位置）来存储，所以显然需要开一个结构体。其次，因为要把时间复杂度控制在线性上面，所以显然需要预处理，也就是按输入的位置来排序2.其次，我们需要另开一个结构体数组来存贮之后的状态3.在对下标的处理中，我们需要另开一个数组来改变下标对蚂蚁的映射关系，使输出的序列满足从小到大4.可能有人还比较模糊，看代码5.附上AC代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define maxn 10005using namespace std;struct node&#123; int s;//存位置 int h;//存方向 int num;//存下标&#125;q[maxn],p[maxn];//q用来保存初状态，p用来保存末状态bool cmp(node x,node y)&#123; return x.s&lt;y.s;&#125; int n,t;int a,b; int order[maxn];//改变的映射关系int main()&#123; cin&gt;&gt;n&gt;&gt;t; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; q[i].s=a; q[i].h=b; q[i].num=i; p[i].s=a+b*t;//t的正负代表了向右还是向左 p[i].num=0;//对于p数组是用来通过order的映射输出的所以不需要 p[i].h=b; &#125; sort(q+1,q+1+n,cmp);//预处理 for(int i=1;i&lt;=n;i++) &#123; order[q[i].num]=i;//从左到右的蚂蚁编号映射成现在sort后对应的下标 &#125; sort(p+1,p+1+n,cmp);//同样，将蚂蚁按从左到右排列 for(int i=1;i&lt;=n;i++) &#123; if(p[i].s==p[i+1].s)//这个是用来考虑判断是否正在经历相遇转向的过程 &#123; p[i].h=0; p[i+1].h=0; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; int g=order[i]; //再通过映射关系，获得根据输入数据而获得的标号，实现相遇时的反向，交换，下面有一波打表 //大概就是说第i个输入的数现在在第几个位置上 cout&lt;&lt;p[g].s&lt;&lt;" "&lt;&lt;p[g].h&lt;&lt;endl; &#125; return 0;&#125; n=3； t=2； q[1].s=3;q[1].num=1;q[1].h=-1; q[2].s=2;q[2].num=2;q[1].h=1; q[3].s=1;q[3].num=3;q[3].h=1; p[1].s=1;p[1].h=-1; p[2].s=4;p[2].h=1; p[3].s=3;p[3].h=1; sort1: q[1].num=3;q[2].num=2;q[3].num=1; order[1]=3;order[2]=2;order[3]=1; sort2: p[1].s=1;p[2].s=3;p[3].s=4; for: i=1:g=3; i=2:g=2; i=3:g=1;]]></content>
      <tags>
        <tag>7-26 only for S.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSP旅行商问题-位运算-Sabrina-Sabrinadol]]></title>
    <url>%2F2019%2F07%2F25%2FTSP%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97-Sabrina-Sabrinadol%2F</url>
    <content type="text"><![CDATA[TSP问题 (tsp.cpp/c/pas) Time Limit : 1 sec ， Memory Limit : 128MB Description 对于给定的加权有向图G(V,E)，查找满足以下条件的最短路径的距离:  这条路径是一个环，即这条路径的起点和终点都是同一个点。  每个顶点只能访问一次。 Input |V| |E| s0 t0 d0 s1 t1 d1 : s|E|−1 t|E|−1 d|E|−1 |V| 是顶点数，|E|是边数。顶点以数字 0, 1,…, |V|-1表示。 si 和ti 表示第i条边(有向)的源和目标顶点，di 表示si和 ti (第i条边)之间的距离。 Output 在一行中输出最短距离。如果没有解决方案，则输出 -1。 Constraints  2 ≤ |V| ≤ 15  0 ≤ di ≤ 1,000  没有多重边Sample Input 1 4 6 0 1 2 1 2 3 1 3 9 2 0 1 2 3 6 3 2 4 Sample Output 1 16Sample Input 2 3 3 0 1 1 1 2 1 0 2 1 Sample Output 2 -1 题解1.首先看到本题，绝大多数人的想法都是DFS，虽然时间复杂度有点高，但是一看数据，又不太，只要我们在深搜中加上记忆化处理，顺便剪一剪枝，也是可以过的 但是！！我想说的不是DFS，而是带上动规的思想。 如下（1）（实现需要使用位运算，等会说）首先假设出一个dp[s][k],s代表已经被扫到的元素的集合，k代表刚进入集合，这里我们是不是就需要列出和k相连的元素（i），然后判定该元素是否已经属于该集合，如果不，就向下扫取最小值动规方程：dp[s][i]=min{dp[s+i][i]+d[k][i]}//d数组存储的是图（2）边界处理1.记忆化处理，当我们扫到的dp值大于0的时候，说明该点已经被扫过了，直接返回值就好2.当扫到初始点的时候，直接返回dp=0就好了（3）元素属于判断以及判断是否扫完每一个元素首先我们知道每种元素只有在集合中和不在集合中两种状态，所以我们可以依靠二进制位运算来表示每个元素的状态，0为不在，1为在 插入：位运算-其实一共就是五种通过二进制位来实现1.&amp;：与 两个二进制位都为1才12.|：或 两个二进制位只要有一个为1就为13.^:异或 相同为1，相反为04.&lt;&lt;左移 将整个数的二进制位左移 右补0 左舍5.&gt;&gt; 右移 溢出补0 左补0 右舍这篇文章写得通俗易懂 （4）代码，有详细注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define maxn 99999using namespace std; int moving[1&lt;&lt;16][100];int a[1000][1000];int b,c,d;int n,m;int search(int s,int k)&#123; if(moving[s][k]&gt;=0) //这里就是上面所说的记忆化 return moving[s][k]; if(s==(1&lt;&lt;n)-1&amp;&amp;k==0)//如果s已满那么加一就会进位到2的n次方，k等于代表回到起点 return moving[s][k]=0;//已经回到了，不再有值 int num=9999; for(int i=0;i&lt;n;i++) &#123; if(!(s&gt;&gt;i&amp;1))//先判定i点是否加入了集合 &#123; num=min(num,search(s|1&lt;&lt;i,i)+a[k][i]); //如果没加入集合就取小，这里因为我们将a数组初始化得大于最大值，所以不用考虑能否到达 &#125; &#125; return moving[s][k]=num;&#125;int main()&#123; //freopen("tsp.in","r",stdin); //freopen("tsp.out","w",stdout); memset(moving,-1,sizeof(moving)); memset(a,0x3f,sizeof(a)); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;b&gt;&gt;c&gt;&gt;d; a[b][c]=d; &#125; long long int kk=search(0,0); if(kk==9999||kk&lt;0) cout&lt;&lt;"-1";//如果值未更新的话，就相当没有找到 else cout&lt;&lt;kk; while(1) cout&lt;&lt;"by Sabrinadol"&lt;&lt;endl;//防copy fclose(stdin); fclose(stdout); return 0;&#125; –Sabrinadol]]></content>
  </entry>
  <entry>
    <title><![CDATA[数学筛法--很全--在noip中的运用]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%95%B0%E5%AD%A6%E7%AD%9B%E6%B3%95-%E5%BE%88%E5%85%A8-%E5%9C%A8noip%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#1.求素数用到的方法 ####（1）普通枚举 枚举到sqrt（n）就好 ####（2）朴素筛法通过对每个数有无非平凡因子来判断朴素筛法 nlogn ，这个时间复杂度的计算有些复杂如下n/2+n/3+n/4+…..+n/n;n(1/2+1/3+1/4+….+1/n)后面那一坨大致就约等于 ln（n） （学过数竞应该知道） 12345678910111213int a[maxn],b[maxn],n;int cnt=0;//筛出 2 到 n 中的所有素数 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//从i+i往后筛所有的倍数 a[j]=1; &#125;&#125; ####（3）埃式筛法通过素因子来筛 123456789101112131415int a[maxn],b[maxn],n;int cnt=0;//优化， nloglogn ，这里的计算跟上个差不多，埃式筛法 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) &#123; b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//将此循环体拿到if依据里面 //意思就是，在遍历筛的时候遇到的如果是合数就不用筛了，优化 a[j]=1; &#125; &#125;&#125; ####（4）线性筛（欧拉筛） 123456789101112131415void oula_sieve(int n)&#123; int cnt=0; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=a[i]; for(int j=0;b[j]*i&lt;=n;j++) &#123; a[b[j]*i]=1;// 保证b[j]是i*b[j]1的最小素因子 if(i%b[j]==0) break; &#125; &#125;&#125; 大家可能对以上三种方法及其优化思路还有疑问，下面加深讲解1.基本思想其实都是先筛掉有非平凡因数的合数筛掉，再进行存储2.举下面 一个栗子比如说我们要筛 12这个数（1）朴素筛 ： 除1外每个数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 ： 2 3 4 6（2）埃氏筛 ： 除1外每个质因数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 : 2 3 （3）欧拉筛 ：可能有人不太懂1–j代表的是下标2–b[]存储找到的素数代码中的第二重（if依据巧妙避开求重）可以让标记只让当前找到的素因数往后标记3–还是举12的例子12的最小质因数会将12筛出也就是只有：2 ###4–总结欧拉筛：每次用已筛出来的质数去筛更大的数，每个合数只被它最小的质因子筛掉，试想，如果26筛了12之后还没break，而是用36筛掉18，那么18还会被29筛一次，就重复了而根本原因就是6有2这个因子，而36筛掉的数一定也有2这个因子，3*6这个数应该被2这个因子筛掉，而不是3]]></content>
  </entry>
  <entry>
    <title><![CDATA[Newpost]]></title>
    <url>%2F2019%2F07%2F24%2FNewpost%2F</url>
    <content type="text"><![CDATA[Hi]]></content>
  </entry>
  <entry>
    <title><![CDATA[拓朴排序]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%8B%93%E6%9C%B4%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.什么是拓扑排序呢拓扑排序是指将将要做的事情先进行排序，在处理时按照顺序处理。]]></content>
      <categories>
        <category>NOIPLearning</category>
      </categories>
  </entry>
</search>
