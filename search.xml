<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[课题--细析费马小定理--ZOJ3785，P2842]]></title>
    <url>%2F2019%2F07%2F28%2F%E8%AF%BE%E9%A2%98-%E7%BB%86%E6%9E%90%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86-%E4%BB%8E%E6%87%82%E5%88%B0%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[0.写在前面在学习费马小定理之前，需要掌握一些数论基本知识 (0).≡-这个符号指的是左右两边的数对p求模结果相同。这里不需要太过纠结，就当做有特殊意义的等号吧。 （1）.同余同余就是指 当 c能够整除（a-b） 时，我们就称 a,b关于模 c同余 记作： （a-b）≡0（mod c）,a≡b(mod c)-补充几个性质（仅作积累，在费马小定理作用不大）当 a≡ b（mod x） c≡ d (mod x)时;满足：1.(a+c)≡ (b+d)(mod x);2.ac≡bd(mod x);3.a-c≡ (b-d)(mod x); (2).逆元（解决数论中的除法）补充 ：数论中的加减乘（a+b）%c=(a%c+b%c)%c; (a-b)%c=(a%c-b%c)%c;ab%c=(a%cb%c)%c;假如题目中数据过大就可以步步取模防止溢出记得以前数学学习中的倒数吗。一个数除以另一个数，就相当于乘以这个数的倒数。在数论中：在取模的情况下，如果要求两个数相除，那么有有可能出现小数。这个时候我们就需要引入一个乘法逆元的概念： 当a*b≡ 1（mod p）时，我们就称 b是 a关于模p的逆元##注意##：（1）当p是一个素数时，则每个数都有唯一的确定的逆元。（2）当 a是b的逆元时，b也是a的逆元（3）0没有逆元（就像0没有倒数一样） 举例 当 p=5，a=2时； b=3； （3）筛法求素数（因为费马小定理的性质，所以判定是否为素数是必备的技能）-1.求素数用到的方法（1）普通枚举 枚举到sqrt（n）就好（2）朴素筛法通过对每个数有无非平凡因子来判断朴素筛法 nlogn ，这个时间复杂度的计算有些复杂如下n/2+n/3+n/4+…..+n/n;n(1/2+1/3+1/4+….+1/n)后面那一坨大致就约等于 ln（n） （学过数竞应该知道） 12345678910111213int a[maxn],b[maxn],n;int cnt=0;//筛出 2 到 n 中的所有素数 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//从i+i往后筛所有的倍数 a[j]=1; &#125;&#125; （3）埃式筛法通过素因子来筛 123456789101112131415int a[maxn],b[maxn],n;int cnt=0;//优化， nloglogn ，这里的计算跟上个差不多，埃式筛法 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) &#123; b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//将此循环体拿到if依据里面 //意思就是，在遍历筛的时候遇到的如果是合数就不用筛了，优化 a[j]=1; &#125; &#125;&#125; （4）线性筛（欧拉筛） 123456789101112131415void oula_sieve(int n)&#123; int cnt=0; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=a[i]; for(int j=0;b[j]*i&lt;=n;j++) &#123; a[b[j]*i]=1;// 保证b[j]是i*b[j]1的最小素因子 if(i%b[j]==0) break; &#125; &#125;&#125; 大家可能对以上三种方法及其优化思路还有疑问，下面加深讲解1.基本思想其实都是先筛掉有非平凡因数的合数筛掉，再进行存储2.举下面 一个栗子比如说我们要筛 12这个数（1）朴素筛 ： 除1外每个数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 ： 2 3 4 6（2）埃氏筛 ： 除1外每个质因数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 : 2 3 （3）欧拉筛 ：可能有人不太懂1–j代表的是下标2–b[]存储找到的素数代码中的第二重（if依据巧妙避开求重）可以让标记只让当前找到的素因数往后标记3–还是举12的例子12的最小质因数会将12筛出也就是只有：2 4–总结欧拉筛： 每次用已筛出来的质数去筛更大的数，每个合数只被它最小的质因子筛掉，试想，如果26筛了12之后还没break，而是用36筛掉18，那么18还会被29筛一次，就重复了而根本原因就是6有2这个因子，而36筛掉的数一定也有2这个因子，3*6这个数应该被2这个因子筛掉，而不是3 4.最大公约数–gcd（学会gcd是费马小定理前提）gcd（a，b）指的是a，的最大公约数如果a，b互质那么 gcd（a，b）=1；一般来讲我们求gcd是通过辗转相除法的就是 gcd(a,b)=gcd(a,b%a);满足a&gt;b这里直接套一个递归就好了 123456789101112int gcd(int a,int b)&#123; return b == 0 ? a : gcd(b,a % b);&#125;//这个玩意可以这么读：b == 0否?b == 0的话返回a,b != 0的话返回gcd(b,a%b)//就是辗转相除，除到0了那么上一个除数就是最大公约数int gcd(int a,int b)&#123; if(b==0) return a; return (b,a%b);&#125; 1.费马小定理（1）.内容：-同余式写法：当 gcd（p，a）=1 ，p是一个质数时；a^p − 1 =1(mod p);当a不能被素数p整除时，(a^p-1 )- 1一定能被p整除; (2).证明在各种证明方法中，同余的方法最为简单 （1）.特殊举例证明 任意取一个质数，比如13。考虑从1到12的一系列整数1,2,3,4,5,6,7,8,9,10,11,12，给这些数都乘上一个与13互质的数，比如3，得到3,6,9,12,15,18,21,24,27,30,33,36。对于模13来说，这些数同余于3,6,9,12,2,5,8,11,1,4,7,10。这些余数实际上就是原来的1,2,3,4,5,6,7,8,9,10,11,12，只是顺序不同而已。 把1,2,3,„,12统统乘起来，乘积就是12的阶乘12！。把3,6,9,„,36也统统乘起来，并且提出公因子3，乘积就是312×12！。对于模13来说，这两个乘积都同余于1,2,3,„,12系列，尽管顺序不是一一对应，即312×12！≡12！mod 13。两边同时除以12！得312≡1 mod 13。如果用p代替13，用x代替3，就得到费马小定理。 （2）一般化证明 取素数p，以及数列{ a，2a,3a,…………….,(p-1)a}； 这个数列中所有元素模p可以取遍1到p-1之间的所有数对于此句话的证明 反证法： 如果不满足，那么必有 k1a(mod p)=k2a(mod p)，并且满足1=&lt;k1&lt;=k2&lt;=p-1; 由此可得 (k1a-k2a)=0(mod p) 又因为 gcd（a,p）=1,所以k1-k2=0(mod p),再看范围，很明显错误 证毕 我们把数列中每个元素都乘起来，得到以下式子 a1a2a*3……a*(p-1)≡(p-1）!(mod p); 约掉（p-1）！ 就可以得到 a^p − 1 =1(mod p); (3).运用1.简单举例如果现在我们要去求 2^100（mod 13）=？很明显该数过大，不过我们首先可以考虑用二分的思想，一层一层取模运算。但是有没有更好的办法呢？肯定是有的从费马小定理出发，我们是否可以将这个一百化为 n*（p-1）+k，n直接用100/12向下取整就好了，这样的话，我们就直接考虑 2^4(mod 13)=? 2.快速求逆元我们对原式进行处理(a^p-2)*a=1(mod p);根据我们对逆元的定义，是否 a^p-2就是a关于p的逆元这里的求解，因为一般题目中的数据都是较大的，所以需要快速幂 补充一段快速幂算法代码 123456789101112131415161718192021222324int rapidmi(int x, int y)&#123; int result = 1; // 定义变量 while (y &gt; 0) // 当指数大于 0 时进行幂运算 &#123; if (y &amp; 1) // y 和 1 做与运算,相当于对 2 求模 &#123; result = result * x; // 如果 y 为奇数,则结果成一个 x &#125; x = x * x; // x 乘二次方,下次使用 y = y &gt;&gt; 1; // y 右移一位,相当于除以 2 &#125; return result; // 返回结果 &#125;int main()&#123; int x, y； while (scanf("%d %d", &amp;x, &amp;y)) &#123; printf("%d ^ %d = %d\n", x, y, rapidmi(x, y)); &#125; return 0;&#125; 给出一般用费马小定理求逆元(P3381会超时3个点)题目：输入 n,m;求出 n在模m意义下的逆元 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define maxn 3000003#define ll long long int using namespace std;int n,m;ll rapid(ll a,ll b)&#123; ll result=1; while(b&gt;0) &#123; if(b&amp;1)//相当取2的模 &#123; result=result*a; &#125; a*=a; b/=2; &#125; return result;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;rapid(n,m-2);//根据定义，就应该是 n的m-2次方 return 0;&#125; 3.两道列题ZOJ3785传送门 ZOJ3785题面来自谷歌翻译今天星期六，S.和L.一起出去游玩，突然S.提出一个问题1^1 + 2^2 + 3^3 + … + N^N天后的哪一天？L.一下子就解答了，你能吗？输入有多个测试用例。 第一行输入包含一个整数T，表示测试用例的数量。 对于每个测试用例： 只有一行包含一个整数N（1 &lt;= N &lt;= 1000000000）。 产量对于每个测试用例，输出一个表示星期几的字符串。 样本输入212样本输出SundayThursday暗示一周包括周日，周一，周二，周三，周四，周五和周六。Jīntiān xīngqíliù,11 + 22 + 33 +… + NN tiānhòu de nǎ yītiān? Shūrùyǒu duō gè cèshì yònglì. Dì yīxíng shūrù bāohán yīgè zhěngshù T, biǎoshì cèshì yònglì de shùliàng. Duìyú měi gè cèshì yònglì: Zhǐyǒu yī xíng bāohán yīgè zhěngshù N(1 &lt;= N &lt;= 1000000000). Chǎnliàngduìyú měi gè cèshì yònglì, shūchū yīgè biǎoshì xīngqí jǐ de zìfú chuàn. Yàngběn shūrù212yàngběn shūchūxīngqírìxīngqísìànshìyīzhōu bāokuò zhōu rì, zhōuyī, zhōu’èr, zhōusān, zhōu sì, zhōu wǔ hé zhōu liù. 题解Sabrina看到这道题有点感觉有点难了但是一旁的同学笑了笑，这是一道非常水的题，用上费马小定理秒杀哦！ 我们知道n^n%7= (n%7)^ n%7,令n%7=m，就相当于n-7[n/7]则原式=(m^ m%7)(m^ (n-m)%7)%7举个例子，9 ^9%7=2 ^9%7=((2 ^2%7)*(2 ^7%7)) %7，所以只要让(2 ^7%7)这个部分等于1，而且这一部分，2的幂肯定是7的倍数，那么循环节就出现了，循环节的开端为m ^m%7(m&lt;7)。我们知道(2 ^a%7) ^b%7=x ^ab%7，让该公式为1，且ab为7的倍数，则a等于6（费马小定理），得ab的最小值为42，也就是要重复就经过了42种情况，所以n^n%7的循环节为42 294=42*7,即为11 + 22 + 33 + … + NN %7的循环节但是Sabrina还是有一点疑惑，于是有了下面几张图 12345678910这个题中我们的p也就是一周的天数7，最开始的形式：1^1 2^2 3^3 4^4 5^5 6^6 7^78^8 9^9 10^10 11^11 12^12 13^13 14^1415^15 16^16 17^17 18^18 19^19 20^20 21^2122^22 23^23 24^24 25^25 26^26 27^27 28^2829^29 30^30 31^31 32^32 33^33 34^34 35^3536^36 37^37 38^38 39^39 40^40 41^41 42^4243^43 44^44 45^45 46^46 47^47 48^48 49^49 这里就相当于n-7*[n/7]的过程 费马小定理转化后–&gt;&gt;（分别取6的模，然后来减掉）1^1 2^2 3^3 4^4 5^5 6^0 0^11^2 2^3 3^4 4^5 5^0 6^1 0^21^3 2^4 3^5 4^0 5^1 6^2 0^31^4 2^5 3^0 4^1 5^2 6^3 0^41^5 2^0 3^1 4^2 5^3 6^4 0^51^0 2^1 3^2 4^3 5^4 6^5 0^01^1 2^2 3^3 4^4 5^5 6^0 0^1最后一行重复，循环节长度为42 （2）P2842 LJJ算数-传送门 题目描述LJJ刚上完了一节课！这节课是数学课！他知道了加减属于一级运算，乘除属于二级运算，幂则属于三级运算，而幂的优先级&gt;乘除的优先级&gt;加减的优先级（这是几年级的数学课）。但是，从上一套试卷+上一题中，我们知道了LJJ是一个总是突发奇想并且智商不够的人（也就是说他又想出一个问题给你咯）。他发明了一种四级运算，我们姑且用符号#来表示（找不到别的符号了）。我们知道ab=a+a+a+…+a(加b次)，a^b=aaaa…a(乘b次)，则a#b=a^a^a^a^…^a(进行幂运算b次)，自然，#的优先级比幂的优先级高。那么，LJJ就请你来帮他求a#b mod 1000000007咯。（PS:这是本试卷最简单的一道题） 输入格式输入仅1行，即a,b。 输出格式输出仅1行，即a#b mod 1000000007。 输入输出样例输入 #1 复制3 5输出 #1 复制968803245说明/提示首先说明，样例答案不mod其实是4.4342648824303776994824963061915e+38（来自出题人的恶意） 然后，数据范围： 对于20%的数据，a&lt;=1000,b&lt;=1000 对于50%的数据，a&lt;=10^16,b&lt;=10000 对于100%的数据，a&lt;=10^16,b&lt;=10^16 （1）.算法分析-本题的意思就是指 求 a的b幂次方也就是 （a） ^(a)^…将此式简化得到 a ^ (a) ^ (b-1)那么到了这个时候很明显就需要分两步来求解，一部分是 a ^ (b-1) 另一部分则是求 a^ (k)为了方便设 k=a ^ (b-1)； 1–第一部分的求解，因为b-1次方仍然过大，可以进一步取模根据费马小定理可以得到a ^ m (mod p)=a ^(m mod p-1 ) (mod p） 证明： a ^ m% p= a ^ (n(p-1) a^(m%(p-1))%p(次数相加，n指的是m/p-1向下取整)由费马小定理可以得到： a^ (n*(p-1))%p==1;所以： a^ m%p= a^(m%(p-1))%p;这里就是把 a^b-1看做m就好了证毕 2–第二部分：直接用第一部分的值，上快速幂就好 3–注意点，我们在快速幂的函数，要小心代表模大小的参数，因为，由式子可知，第一次是取得 q-1第二次取的是 q； （2）附上AC代码123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define maxn 3000003using namespace std;long long int n,m;const long long int modl = 1000000007;long long int rapidmi(long long int x,long long int y,long long int z)&#123; long long int result = 1; // 定义变量 x%=z; while (y &gt; 0) // 当指数大于 0 时进行幂运算 &#123; if (y &amp; 1) // y 和 1 做与运算,相当于对 2 求模 &#123; result = result * x%z; // 如果 y 为奇数,则结果成一个 x &#125; x = x * x%z; // x 乘二次方,下次使用 y = y &gt;&gt; 1; // y 右移一位,相当于除以 2 &#125; return result; // 返回结果 &#125;int main()&#123; int x, y; cin&gt;&gt;n&gt;&gt;m; long long int k=rapidmi(n,m-1,modl-1); long long int yo=rapidmi(n,k,modl); cout&lt;&lt;yo&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>2019课题 only for her</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题-POJ1852-P1367--思维题--详解]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%9A%82%E8%9A%81%E9%97%AE%E9%A2%98-POJ1852-P1367-%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[POJ1852蚂蚁时间限制： 1000MS 内存限制： 30000K提交总数： 31489 接受： 11801描述 一队蚂蚁在长度为1厘米的水平杆上行走，每根杆的速度恒定为1厘米/秒。当一只行走的蚂蚁到达极的一端时，它会立即从它上掉下来。当两只蚂蚁相遇时，它们会转身并开始向相反方向行走。我们知道蚂蚁在杆子上的原始位置，不幸的是，我们不知道蚂蚁行走的方向。你的任务是计算所有蚂蚁从杆上掉下来所需的最早和最晚时间。输入 第一行输入包含一个整数，给出后面的案例数。每种情况的数据都以两个整数开始：极点长度（cm）和n，极点上的蚂蚁数量。这两个数字之后是n个整数，它们将杆上每只蚂蚁的位置作为从杆的左端测量的距离，没有特别的顺序。所有输入整数都不大于1000000，它们由空格分隔。产量 对于每种输入情况，输出由单个空格分隔的两个数字。第一个数字是所有蚂蚁从杆上掉下来的最早时间（如果他们的步行方向选择得恰当），第二个数字是最久可能的时间。样本输入 210 32 6 7214 711 12 7 13 176 23 191样本输出 4 838 207资源 滑铁卢当地人2004.09.19 题解1.算法思想我们·来看本题，直接对结果进行分析，是不是可以知道每个蚂蚁的最终的结果都是落了下来。其次题目中提到了，在两只蚂蚁相遇的过程中，两只蚂蚁会反向，首先我们的想法就是直接枚举，但是这样的时间复杂度显然是 2^n,不用想就要舍弃。既然是求最值，那么肯定跟贪心什么的有关系。回到蚂蚁反向的时刻，虽然蚂蚁反向了，但是两只蚂蚁的最终结果难道不都是掉下去了吗，并且两只蚂蚁并没有任何区别，那么我们可不可以看做两只蚂蚁并未反向，而是进行了灵魂交换。。。？想到这里问题就很明朗了，通过贪心的策略，对于每一只蚂蚁而言，最长时间就是朝向离自己最远的一端，最近时间就是朝向离自己最近的一端。直接套上一个循环然后求最值即可；2.核心代码讲解 12345678910int lmi=0,lmx=0; for(int i=1;i&lt;=m;i++) &#123; lmi=max(lmi,min(a[i],n-a[i])); //动态求最小值 //因为是时间，所以要满足时间最长的蚂蚁能够掉下去，所以要在原最小值和现最小值间取最大值 lmx=max(lmx,max(a[i],n-a[i])); //同理 &#125; cout&lt;&lt;lmi&lt;&lt;" "&lt;&lt;lmx&lt;&lt;endl; 3.附上AC代码 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define maxn 1000005using namespace std;int t;int a[maxn];int n,m; int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) cin&gt;&gt;a[i]; int lmi=0,lmx=0; for(int i=1;i&lt;=m;i++) &#123; lmi=max(lmi,min(a[i],n-a[i])); lmx=max(lmx,max(a[i],n-a[i])); &#125; cout&lt;&lt;lmi&lt;&lt;" "&lt;&lt;lmx&lt;&lt;endl; &#125; while(1) cout&lt;&lt;"Sabrina"&lt;&lt;endl;//防copy return 0;&#125; P1367题目描述有许多蚂蚁在一根无限长的木棍上，每一只蚂蚁都有一个初始位置和初始朝向（任意两只蚂蚁的初始位置不同）。蚂蚁们以每秒一个单位的速度向前移动，当两只蚂蚁相遇时，它们会掉头（掉头时间忽略不计）。现给出每只蚂蚁的初始位置和初始朝向，请你计算出它们在t秒后的位置和朝向。 输入格式第一行，两个空格隔开的整数n，t（代表蚂蚁数n和时间t） 第2~n+1行每行两个整数，第i+1行代表第i只蚂蚁的初始位置ai（ai的绝对值在1000000以内）及初始朝向bi（bi=1时蚂蚁朝右，bi=-1时蚂蚁朝左） 输出格式n行，每行两个整数，第i行代表t秒后第i只蚂蚁的位置及朝向（-1表示朝左，1表示朝右，0表示正在转向中） 输入输出样例输入 #1 复制4 11 15 13 -110 1输出 #1 复制2 06 12 011 1说明/提示【数据范围】 对于40%的数据，n&lt;=100 对于80%的数据，n&lt;=10000,t&lt;=1000 对于100%的数据，n&lt;=100000,t&lt;=100000 题解1.算法思想此题相对而言就要稍微复杂一些，可以称其为升级版。 整体思路看到本题，很明显，经过上一道题的练习，我们很容易想到只管初末状态，在更换灵魂的时候只需要换一下数组下标，最后直接输出就好 具体实现1.因为关于一个下标，我们有两个数据（方向，位置）来存储，所以显然需要开一个结构体。其次，因为要把时间复杂度控制在线性上面，所以显然需要预处理，也就是按输入的位置来排序2.其次，我们需要另开一个结构体数组来存贮之后的状态3.在对下标的处理中，我们需要另开一个数组来改变下标对蚂蚁的映射关系，使输出的序列满足从小到大4.可能有人还比较模糊，看代码5.附上AC代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define maxn 10005using namespace std;struct node&#123; int s;//存位置 int h;//存方向 int num;//存下标&#125;q[maxn],p[maxn];//q用来保存初状态，p用来保存末状态bool cmp(node x,node y)&#123; return x.s&lt;y.s;&#125; int n,t;int a,b; int order[maxn];//改变的映射关系int main()&#123; cin&gt;&gt;n&gt;&gt;t; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; q[i].s=a; q[i].h=b; q[i].num=i; p[i].s=a+b*t;//t的正负代表了向右还是向左 p[i].num=0;//对于p数组是用来通过order的映射输出的所以不需要 p[i].h=b; &#125; sort(q+1,q+1+n,cmp);//预处理 for(int i=1;i&lt;=n;i++) &#123; order[q[i].num]=i;//从左到右的蚂蚁编号映射成现在sort后对应的下标 &#125; sort(p+1,p+1+n,cmp);//同样，将蚂蚁按从左到右排列 for(int i=1;i&lt;=n;i++) &#123; if(p[i].s==p[i+1].s)//这个是用来考虑判断是否正在经历相遇转向的过程 &#123; p[i].h=0; p[i+1].h=0; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; int g=order[i]; //再通过映射关系，获得根据输入数据而获得的标号，实现相遇时的反向，交换，下面有一波打表 //大概就是说第i个输入的数现在在第几个位置上 cout&lt;&lt;p[g].s&lt;&lt;" "&lt;&lt;p[g].h&lt;&lt;endl; &#125; return 0;&#125; n=3； t=2； q[1].s=3;q[1].num=1;q[1].h=-1; q[2].s=2;q[2].num=2;q[1].h=1; q[3].s=1;q[3].num=3;q[3].h=1; p[1].s=1;p[1].h=-1; p[2].s=4;p[2].h=1; p[3].s=3;p[3].h=1; sort1: q[1].num=3;q[2].num=2;q[3].num=1; order[1]=3;order[2]=2;order[3]=1; sort2: p[1].s=1;p[2].s=3;p[3].s=4; for: i=1:g=3; i=2:g=2; i=3:g=1;]]></content>
      <tags>
        <tag>7-26 only for S.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MY课题--费马小定理入门--ZOJ3785]]></title>
    <url>%2F2019%2F07%2F25%2FMY%E8%AF%BE%E9%A2%98-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E5%85%A5%E9%97%A8-ZOJ3785%2F</url>
    <content type="text"><![CDATA[0.写在前面因为费马小定理的使用需要满足两个数是否互质（数论中大部分定理都需要，so，我接下来讲的worth积累） 先补充筛法1.求素数用到的方法（1）普通枚举 枚举到sqrt（n）就好（2）朴素筛法通过对每个数有无非平凡因子来判断朴素筛法 nlogn ，这个时间复杂度的计算有些复杂如下n/2+n/3+n/4+…..+n/n;n(1/2+1/3+1/4+….+1/n)后面那一坨大致就约等于 ln（n） （学过数竞应该知道） 12345678910111213int a[maxn],b[maxn],n;int cnt=0;//筛出 2 到 n 中的所有素数 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//从i+i往后筛所有的倍数 a[j]=1; &#125;&#125; （3）埃式筛法通过素因子来筛 123456789101112131415int a[maxn],b[maxn],n;int cnt=0;//优化， nloglogn ，这里的计算跟上个差不多，埃式筛法 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) &#123; b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//将此循环体拿到if依据里面 //意思就是，在遍历筛的时候遇到的如果是合数就不用筛了，优化 a[j]=1; &#125; &#125;&#125; （4）线性筛（欧拉筛） 123456789101112131415void oula_sieve(int n)&#123; int cnt=0; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=a[i]; for(int j=0;b[j]*i&lt;=n;j++) &#123; a[b[j]*i]=1;// 保证b[j]是i*b[j]1的最小素因子 if(i%b[j]==0) break; &#125; &#125;&#125; 大家可能对以上三种方法及其优化思路还有疑问，下面加深讲解1.基本思想其实都是先筛掉有非平凡因数的合数筛掉，再进行存储2.举下面 一个栗子比如说我们要筛 12这个数（1）朴素筛 ： 除1外每个数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 ： 2 3 4 6（2）埃氏筛 ： 除1外每个质因数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 : 2 3 （3）欧拉筛 ：可能有人不太懂1–j代表的是下标2–b[]存储找到的素数代码中的第二重（if依据巧妙避开求重）可以让标记只让当前找到的素因数往后标记3–还是举12的例子12的最小质因数会将12筛出也就是只有：2 4–总结欧拉筛： 每次用已筛出来的质数去筛更大的数，每个合数只被它最小的质因子筛掉，试想，如果26筛了12之后还没break，而是用36筛掉18，那么18还会被29筛一次，就重复了而根本原因就是6有2这个因子，而36筛掉的数一定也有2这个因子，3*6这个数应该被2这个因子筛掉，而不是3 然后是gcdgcd（a，b）指的是a，的最大公约数如果a，b互质那么 gcd（a，b）=1；一般来讲我们求gcd是通过辗转相除法的就是 gcd(a,b)=gcd(a,b%a);满足a&gt;b这里直接套一个递归就好了 123456789101112int gcd(int a,int b)&#123; return b == 0 ? a : gcd(b,a % b);&#125;//这个玩意可以这么读：b == 0否?b == 0的话返回a,b != 0的话返回gcd(b,a%b)//就是辗转相除，除到0了那么上一个除数就是最大公约数int gcd(int a,int b)&#123; if(b==0) return a; return (b,a%b);&#125; 1.内容当gcd（a，p）=1时a^(p-1)=1(mod p)a的p-1次方取p的模为1 2.举例如果现在我们要去求 2^100（mod 13）=？很明显该数过大，不过我们首先可以考虑用二分的思想，一层一层取模运算。但是，Sabrina提出了问题：有没有更好的办法呢？肯定是有的从费马小定理出发，我们是否可以将这个一百化为 n*（p-1）+k，n直接用100/12向下取整就好了，这样的话，我们就直接考虑 2^4(mod 13)=?Sabria听到后很开森，不过她仍然意犹未尽，于是有了下面这道例题 3.例题传送门今天星期六，S.和L.一起出去游玩，突然S.提出一个问题1^1 + 2^2 + 3^3 + … + N^N天后的哪一天？L.一下子就解答了，你能吗？输入有多个测试用例。 第一行输入包含一个整数T，表示测试用例的数量。 对于每个测试用例： 只有一行包含一个整数N（1 &lt;= N &lt;= 1000000000）。 产量对于每个测试用例，输出一个表示星期几的字符串。 样本输入212样本输出SundayThursday暗示一周包括周日，周一，周二，周三，周四，周五和周六。Jīntiān xīngqíliù,11 + 22 + 33 +… + NN tiānhòu de nǎ yītiān? Shūrùyǒu duō gè cèshì yònglì. Dì yīxíng shūrù bāohán yīgè zhěngshù T, biǎoshì cèshì yònglì de shùliàng. Duìyú měi gè cèshì yònglì: Zhǐyǒu yī xíng bāohán yīgè zhěngshù N(1 &lt;= N &lt;= 1000000000). Chǎnliàngduìyú měi gè cèshì yònglì, shūchū yīgè biǎoshì xīngqí jǐ de zìfú chuàn. Yàngběn shūrù212yàngběn shūchūxīngqírìxīngqísìànshìyīzhōu bāokuò zhōu rì, zhōuyī, zhōu’èr, zhōusān, zhōu sì, zhōu wǔ hé zhōu liù. 题解Sabrina看到这道题有点感觉有点难了但是一旁的同学笑了笑，这是一道非常水的题，用上费马小定理秒杀哦！ 下面这一小段，由于不太会用MK，所以摘抄自某位仁兄博客(有删改)我们知道n^n%7= (n%7)^ n%7,令n%7=m，就相当于n-7[n/7]则原式=(m^ m%7)(m^ (n-m)%7)%7举个例子，9 ^9%7=2 ^9%7=((2 ^2%7)*(2 ^7%7)) %7，所以只要让(2 ^7%7)这个部分等于1，而且这一部分，2的幂肯定是7的倍数，那么循环节就出现了，循环节的开端为m ^m%7(m&lt;7)。我们知道(2 ^a%7) ^b%7=x ^ab%7，让该公式为1，且ab为7的倍数，则a等于6（费马小定理），得ab的最小值为42，也就是要重复就经过了42种情况，所以n^n%7的循环节为42 294=42*7,即为11 + 22 + 33 + … + NN %7的循环节但是Sabrina还是有一点疑惑，于是有了下面几张图（不是我打的``） 12345678910这个题中我们的p也就是一周的天数7，最开始的形式：1^1 2^2 3^3 4^4 5^5 6^6 7^78^8 9^9 10^10 11^11 12^12 13^13 14^1415^15 16^16 17^17 18^18 19^19 20^20 21^2122^22 23^23 24^24 25^25 26^26 27^27 28^2829^29 30^30 31^31 32^32 33^33 34^34 35^3536^36 37^37 38^38 39^39 40^40 41^41 42^4243^43 44^44 45^45 46^46 47^47 48^48 49^49 这里就相当于n-7*[n/7]的过程 费马小定理转化后–&gt;&gt;（分别取6的模，然后来减掉）1^1 2^2 3^3 4^4 5^5 6^0 0^11^2 2^3 3^4 4^5 5^0 6^1 0^21^3 2^4 3^5 4^0 5^1 6^2 0^31^4 2^5 3^0 4^1 5^2 6^3 0^41^5 2^0 3^1 4^2 5^3 6^4 0^51^0 2^1 3^2 4^3 5^4 6^5 0^01^1 2^2 3^3 4^4 5^5 6^0 0^1最后一行重复，循环节长度为4 Sabrinadol懂了，你懂了吗 4.其实，费马小定理的运用还需要使用一些数论的基本知识（乘法逆元和同余的基本概念），但是应该不会考，so。。。。。]]></content>
      <tags>
        <tag>19年的课题--Sabrinadol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSP旅行商问题-位运算-Sabrina-Sabrinadol]]></title>
    <url>%2F2019%2F07%2F25%2FTSP%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97-Sabrina-Sabrinadol%2F</url>
    <content type="text"><![CDATA[TSP问题 (tsp.cpp/c/pas) Time Limit : 1 sec ， Memory Limit : 128MB Description 对于给定的加权有向图G(V,E)，查找满足以下条件的最短路径的距离:  这条路径是一个环，即这条路径的起点和终点都是同一个点。  每个顶点只能访问一次。 Input |V| |E| s0 t0 d0 s1 t1 d1 : s|E|−1 t|E|−1 d|E|−1 |V| 是顶点数，|E|是边数。顶点以数字 0, 1,…, |V|-1表示。 si 和ti 表示第i条边(有向)的源和目标顶点，di 表示si和 ti (第i条边)之间的距离。 Output 在一行中输出最短距离。如果没有解决方案，则输出 -1。 Constraints  2 ≤ |V| ≤ 15  0 ≤ di ≤ 1,000  没有多重边Sample Input 1 4 6 0 1 2 1 2 3 1 3 9 2 0 1 2 3 6 3 2 4 Sample Output 1 16Sample Input 2 3 3 0 1 1 1 2 1 0 2 1 Sample Output 2 -1 题解1.首先看到本题，绝大多数人的想法都是DFS，虽然时间复杂度有点高，但是一看数据，又不太，只要我们在深搜中加上记忆化处理，顺便剪一剪枝，也是可以过的 但是！！我想说的不是DFS，而是带上动规的思想。 如下（1）（实现需要使用位运算，等会说）首先假设出一个dp[s][k],s代表已经被扫到的元素的集合，k代表刚进入集合，这里我们是不是就需要列出和k相连的元素（i），然后判定该元素是否已经属于该集合，如果不，就向下扫取最小值动规方程：dp[s][i]=min{dp[s+i][i]+d[k][i]}//d数组存储的是图（2）边界处理1.记忆化处理，当我们扫到的dp值大于0的时候，说明该点已经被扫过了，直接返回值就好2.当扫到初始点的时候，直接返回dp=0就好了（3）元素属于判断以及判断是否扫完每一个元素首先我们知道每种元素只有在集合中和不在集合中两种状态，所以我们可以依靠二进制位运算来表示每个元素的状态，0为不在，1为在 插入：位运算-其实一共就是五种通过二进制位来实现1.&amp;：与 两个二进制位都为1才12.|：或 两个二进制位只要有一个为1就为13.^:异或 相同为1，相反为04.&lt;&lt;左移 将整个数的二进制位左移 右补0 左舍5.&gt;&gt; 右移 溢出补0 左补0 右舍这篇文章写得通俗易懂 （4）代码，有详细注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define maxn 99999using namespace std; int moving[1&lt;&lt;16][100];int a[1000][1000];int b,c,d;int n,m;int search(int s,int k)&#123; if(moving[s][k]&gt;=0) //这里就是上面所说的记忆化 return moving[s][k]; if(s==(1&lt;&lt;n)-1&amp;&amp;k==0)//如果s已满那么加一就会进位到2的n次方，k等于代表回到起点 return moving[s][k]=0;//已经回到了，不再有值 int num=9999; for(int i=0;i&lt;n;i++) &#123; if(!(s&gt;&gt;i&amp;1))//先判定i点是否加入了集合 &#123; num=min(num,search(s|1&lt;&lt;i,i)+a[k][i]); //如果没加入集合就取小，这里因为我们将a数组初始化得大于最大值，所以不用考虑能否到达 &#125; &#125; return moving[s][k]=num;&#125;int main()&#123; //freopen("tsp.in","r",stdin); //freopen("tsp.out","w",stdout); memset(moving,-1,sizeof(moving)); memset(a,0x3f,sizeof(a)); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;b&gt;&gt;c&gt;&gt;d; a[b][c]=d; &#125; long long int kk=search(0,0); if(kk==9999||kk&lt;0) cout&lt;&lt;"-1";//如果值未更新的话，就相当没有找到 else cout&lt;&lt;kk; while(1) cout&lt;&lt;"by Sabrinadol"&lt;&lt;endl;//防copy fclose(stdin); fclose(stdout); return 0;&#125; –Sabrinadol]]></content>
  </entry>
  <entry>
    <title><![CDATA[数学筛法--很全--在noip中的运用]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%95%B0%E5%AD%A6%E7%AD%9B%E6%B3%95-%E5%BE%88%E5%85%A8-%E5%9C%A8noip%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#1.求素数用到的方法 ####（1）普通枚举 枚举到sqrt（n）就好 ####（2）朴素筛法通过对每个数有无非平凡因子来判断朴素筛法 nlogn ，这个时间复杂度的计算有些复杂如下n/2+n/3+n/4+…..+n/n;n(1/2+1/3+1/4+….+1/n)后面那一坨大致就约等于 ln（n） （学过数竞应该知道） 12345678910111213int a[maxn],b[maxn],n;int cnt=0;//筛出 2 到 n 中的所有素数 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//从i+i往后筛所有的倍数 a[j]=1; &#125;&#125; ####（3）埃式筛法通过素因子来筛 123456789101112131415int a[maxn],b[maxn],n;int cnt=0;//优化， nloglogn ，这里的计算跟上个差不多，埃式筛法 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) &#123; b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//将此循环体拿到if依据里面 //意思就是，在遍历筛的时候遇到的如果是合数就不用筛了，优化 a[j]=1; &#125; &#125;&#125; ####（4）线性筛（欧拉筛） 123456789101112131415void oula_sieve(int n)&#123; int cnt=0; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=a[i]; for(int j=0;b[j]*i&lt;=n;j++) &#123; a[b[j]*i]=1;// 保证b[j]是i*b[j]1的最小素因子 if(i%b[j]==0) break; &#125; &#125;&#125; 大家可能对以上三种方法及其优化思路还有疑问，下面加深讲解1.基本思想其实都是先筛掉有非平凡因数的合数筛掉，再进行存储2.举下面 一个栗子比如说我们要筛 12这个数（1）朴素筛 ： 除1外每个数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 ： 2 3 4 6（2）埃氏筛 ： 除1外每个质因数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 : 2 3 （3）欧拉筛 ：可能有人不太懂1–j代表的是下标2–b[]存储找到的素数代码中的第二重（if依据巧妙避开求重）可以让标记只让当前找到的素因数往后标记3–还是举12的例子12的最小质因数会将12筛出也就是只有：2 ###4–总结欧拉筛：每次用已筛出来的质数去筛更大的数，每个合数只被它最小的质因子筛掉，试想，如果26筛了12之后还没break，而是用36筛掉18，那么18还会被29筛一次，就重复了而根本原因就是6有2这个因子，而36筛掉的数一定也有2这个因子，3*6这个数应该被2这个因子筛掉，而不是3]]></content>
  </entry>
  <entry>
    <title><![CDATA[today]]></title>
    <url>%2F2019%2F07%2F24%2Ftoday%2F</url>
    <content type="text"><![CDATA[搭了很久的博客终于搞好了，感谢我的两位儿子的帮助Sabrinadol]]></content>
  </entry>
  <entry>
    <title><![CDATA[Newpost]]></title>
    <url>%2F2019%2F07%2F24%2FNewpost%2F</url>
    <content type="text"><![CDATA[Hi]]></content>
  </entry>
  <entry>
    <title><![CDATA[拓朴排序]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%8B%93%E6%9C%B4%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[近日更新敬请期待！]]></content>
      <categories>
        <category>NOIPLearning</category>
      </categories>
  </entry>
</search>
