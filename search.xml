<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最短路]]></title>
    <url>%2F2019%2F09%2F26%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[P1073 最优贸易 展开题目描述CC国有nn个大城市和mm 条道路，每条道路连接这 nn个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 mm 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 11条。 CC国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到 CC 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 CC 国 n 个城市的标号从 1~ n1 n，阿龙决定从 11号城市出发，并最终在 nn 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 nn 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 CC 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设 CC国有 55个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。 假设 1~n1 n 号城市的水晶球价格分别为 4,3,5,6,14,3,5,6,1。 阿龙可以选择如下一条线路：11-&gt;22-&gt;33-&gt;55，并在 22号城市以33 的价格买入水晶球，在 33号城市以55的价格卖出水晶球，赚取的旅费数为 2。 阿龙也可以选择如下一条线路11-&gt;44-&gt;55-&gt;44-&gt;55，并在第11次到达55 号城市时以 11的价格买入水晶球，在第 22 次到达44 号城市时以66 的价格卖出水晶球，赚取的旅费数为55。 现在给出 nn个城市的水晶球价格，mm 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入格式第一行包含 22 个正整数nn和 mm，中间用一个空格隔开，分别表示城市的数目和道路的数目。 第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。 接下来 mm 行，每行有33个正整数x,y,zx,y,z，每两个整数之间用一个空格隔开。如果 z=1z=1，表示这条道路是城市xx到城市yy之间的单向道路；如果z=2z=2，表示这条道路为城市 xx和城市yy之间的双向道路。 输出格式一 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 00。 输入输出样例输入 #1复制5 54 3 5 6 11 2 11 4 12 3 23 5 14 5 2输出 #1复制5说明/提示【数据范围】 输入数据保证 11 号城市可以到达nn号城市。 对于 10%的数据，1≤n≤61≤n≤6。 对于 30%的数据，1≤n≤1001≤n≤100。 对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。 对于 100%的数据，1≤n≤1000001≤n≤100000，1≤m≤5000001≤m≤500000，1≤x1≤x，y≤ny≤n，1≤z≤21≤z≤2，1≤1≤各城市 水晶球价格≤100≤100。 NOIP 2009 提高组 第三题题解对于本题给出以下两种解法搜索求最优解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;vector&lt;int&gt; q[maxn];int m,n,c[maxn];//c用来存储每个城市的价格 int mi[maxn];//mi数组：到达某个城市的的那条路劲上的最小价格 //因为本题中说过可以重复到一个城市，那么我们将mi初始化为最大值，//如果扫到的mi大于我们记录的路劲的最小值，就不断更新 //反之，就说明这条路劲不是最优解，可以返回 int f[maxn];//f数组：表示到每个城市的赚的最多是多少//动态转移方程：f[son]=max(f[father],c[x]-minx);//如果在某一个城市我们进行了f的更新，那么说明我们就可以继续搜索下去//如果没有更新就说明这不是最优解 ，也就满足停止搜索的条件。 int read()&#123; char c=getchar();int x=0,k=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-') k=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*k;&#125;void dfs(int x,int minx,int fa)//x表示当前搜到的哪个点，minx表示这条路劲上面的最小值，fa表示上一个点 &#123; int flag=1; minx=min(minx,c[x]); if(mi[x]&gt;minx) &#123; mi[x]=minx; flag=0; &#125; int num=max(f[fa],c[x]-minx); if(f[x]&lt;num) &#123; f[x]=num; flag=0; &#125; if(flag) return ; for(int i=0;i&lt;q[x].size();i++) &#123; dfs(q[x][i],minx,x); &#125;&#125;void init()&#123; n=read(); m=read(); int a; for(int i=1;i&lt;=n;i++) c[i]=read(); int b,c; for(int i=1;i&lt;=m;i++) &#123; a=read(); b=read(); c=read(); q[a].push_back(b); if(c==2) q[b].push_back(a); &#125; for (int i=0;i&lt;maxn;i++) mi[i]=inf;&#125;const int inf = 1e9+7;int main()&#123; init(); dfs(1,inf,0); cout&lt;&lt;f[n]; return 0;&#125; 两遍spfa求最优解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//很明显除去上一种搜索法，我们可以通过得到最大价格减去最小价格来得到最优解 //点权处理：其实很简单，放到点连的边上去就好了 //最大价格其实也是跑一遍spfa //但是需要注意的是，得到最小价格的点必须要最大价格的前面，这样才能保证后卖先买 //所以求最大价格时反向建边就好了 //最后求解枚举一遍就好了 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define maxn 100005using namespace std;vector&lt;int&gt; q1[maxn],q2[maxn],w1[maxn],w2[maxn];const int inf = 1e9+7;int n,m;int d[maxn];int f[maxn];int c[maxn];int v[maxn];void spfa1()//解决最小值 &#123; memset(d,0x3f,sizeof(d)); memset(v,0,sizeof(v)); queue &lt;int&gt; h1; h1.push(1); v[1]=1; while(h1.size()) &#123; int x=h1.front(); v[x]=0; h1.pop(); for(int i=0;i&lt;q1[x].size();i++) &#123; int to=q1[x][i]; int ans=w1[x][i]; if(d[to]&gt;min(ans,d[x])) &#123; d[to]=min(ans,d[x]); if(!v[to]) &#123; v[to]=1; h1.push(to); &#125; &#125; &#125; &#125;&#125;void spfa2()&#123; memset(f,0,sizeof(f)); memset(v,0,sizeof(v)); v[n]=0; queue&lt;int&gt; h2; h2.push(n); while(h2.size()) &#123; int x=h2.front(); v[x]=0; h2.pop(); for(int i=0;i&lt;q2[x].size();i++) &#123; int to=q2[x][i]; int num=w2[x][i]; if(f[to]&lt;max(num,f[x])) &#123; f[to]=max(num,f[x]); if(!v[to]) &#123; v[to]=1; h2.push(to); &#125; &#125; &#125; &#125;&#125;int read()&#123; char s=getchar();int x=0,k=1; while(s&lt;'0'||s&gt;'9')&#123;if(s=='-') k=-1;s=getchar();&#125; while(s&gt;='0'&amp;&amp;s&lt;='9')&#123;x=x*10+s-'0';s=getchar();&#125; return x*k;&#125;void init()&#123; n=read(); m=read(); int s1; for(int i=1;i&lt;=n;i++) c[i]=read(); int s2,k; for(int i=1;i&lt;=m;i++) &#123; s1=read(); s2=read(); k=read(); if(k==2) &#123; q1[s1].push_back(s2); q1[s2].push_back(s1); w1[s1].push_back(c[s2]); w1[s2].push_back(c[s1]); q2[s2].push_back(s1); q2[s1].push_back(s2); w2[s1].push_back(c[s2]); w2[s2].push_back(c[s1]); &#125; else &#123; q1[s1].push_back(s2); w1[s1].push_back(c[s2]); q2[s2].push_back(s1); w2[s2].push_back(c[s1]); &#125; &#125;&#125;void solve1()&#123; int ans=0; for(int i=1;i&lt;=n;i++) &#123; ans=max(ans,f[i]-d[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; init(); spfa1(); spfa2(); solve1(); return 0;&#125;]]></content>
      <tags>
        <tag>NOIPlearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[DPlearning]]></title>
    <url>%2F2019%2F08%2F31%2FDPlearning%2F</url>
    <content type="text"><![CDATA[1-Conclusion–dp1.一般来讲dp就分为三种：区间dp ，状态压缩dp ，树上dp 2.其实个人觉得dp的题代码都是比较好写的，最重要的就是要找到状态转移方程 3.三种dp中区间dp是最常见也是最重要的，状态压缩在压缩上的实现可能需要一点位运算什么的，树形dp简单一点。 2-区间dp–P1880环状石子合并题解传送门题目描述在一个圆形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分. 输入格式数据的第1行试正整数N,1≤N≤100,表示有N堆石子.第2行有N个数,分别表示每堆石子的个数. 输出格式输出共2行,第1行为最小得分,第2行为最大得分. 输入输出样例输入 #1 复制44 5 9 4输出 #1 复制4354 ##题解##1.题目要求求区间内的最大值以及最小值，很明显就需要通过子区间的状态传递来实现动规操作了。2.本题有一个很重要的点。就是该数据是呈环状的。也就是说我们dp得到的答案是这样的： dp[i][i+n-1]。且1&lt;=i&lt;=n。而并不是一般dp的：dp[1][n];那这个问题怎么解决呢？goodquestion。直接将我们的dp边界扩大一倍。拆环成链。3.dp方程其实很简单。在我们的区间i，j中枚举一个k来求得最小/最大值b数组装得是前缀和 12dp1[i][j]=min(dp1[i][j],dp1[i][k]+dp1[k+1][j]+b[j]-b[i-1]);dp2[i][j]=max(dp2[i][j],dp2[i][k]+dp2[k+1][j]+b[j]-b[i-1]); 4.附上AC代码+注释、 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #define maxn 205 using namespace std;int dp1[maxn][maxn];int dp2[maxn][maxn];int a[305];int b[305]; int n;const int inf = 1e9;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; a[n+i]=a[i];//拆环成链 &#125; for(int i=1;i&lt;=n*2;i++) &#123; b[i]=b[i-1]+a[i];// &#125; for(int l=2;l&lt;=n;l++)//区间长度 &#123; for(int i=1,j;(j=i+l-1)&lt;=2*n;i++)// 因为是环所以边界为2*n &#123; dp1[i][j]=999999999; for(int k=i;k&lt;j;k++) &#123; dp1[i][j]=min(dp1[i][j],dp1[i][k]+dp1[k+1][j]+b[j]-b[i-1]); dp2[i][j]=max(dp2[i][j],dp2[i][k]+dp2[k+1][j]+b[j]-b[i-1]); &#125; &#125; &#125; int f1=1e9+1; int f2=-10; for(int i=1;i&lt;=n;i++) &#123; f1=min(dp1[i][i+n-1],f1); f2=max(dp2[i][i+n-1],f2); &#125; cout&lt;&lt;f1&lt;&lt;endl&lt;&lt;f2; return 0;&#125; 区间dp–P1220关路灯传送门题目描述某一村庄在一条路线上安装了n盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。 为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。 现在已知老张走的速度为1m/s，每个路灯的位置（是一个整数，即距路线起点的距离，单位：m）、功率（W），老张关灯所用的时间很短而可以忽略不计。 请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。 输入格式文件第一行是两个数字n(1&lt;=n&lt;=50，表示路灯的总数)和c(1&lt;＝c&lt;=n老张所处位置的路灯号)； 接下来n行，每行两个数据，表示第1盏到第n盏路灯的位置和功率。数据保证路灯位置单调递增。 输出格式一个数据，即最少的功耗(单位：J，1J＝1W·s)。 输入输出样例输入 #1 复制5 32 103 205 206 308 10输出 #1 复制270说明/提示输出解释： {此时关灯顺序为3 4 2 1 5，不必输出这个关灯顺序} 题解1.对于本题策略应该是很清楚的。看到求区间最值时候就很容易想到dp2.（1）对于本题我们需要一个dp数组dp[i][j]表示从关掉i到j中间的所有路灯的最小值（2）在对区间答案进行求解的时候，因为对于这个区间而言，如果关灯者在左边还是在右边情况是不同的。因为他区间是有长度的，他从左边运动到右边需要花时间。我们就只需要在dp数组上加一维度来表示在左边还是右边。（3）动态转移方程其实是很简单的，就是简单的运用一下区间dp的知识就好了 123456789101112f[i][j][0]=min( f[i+1][j][0]+(s[i+1]-s[i])*(p[n]-p[j]+p[i]), //s[i]表示编号为i的路灯的坐标 //p数组是一个功率的前缀和，使用前缀和比较方便 f[i+1][j][1]+(s[j]-s[i])*(p[n]-p[j]+p[i]));f[i][j][1]=min( f[i][j-1][1]+(s[j]-s[j-1])*(p[n]-p[j-1]+p[i-1]), f[i][j-1][0]+(s[j]-s[i])*(p[n]-p[j-1]+p[i-1])); 3.附上AC代码+注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #define ll long long int #define maxn 105using namespace std;int n,c;int b[maxn];int s[maxn];int p[maxn];int f[maxn][maxn][5];int main()&#123; memset(f,127,sizeof(f)); scanf("%d%d",&amp;n,&amp;c); f[c][c][0]=f[c][c][1]=0;//瞬间被关 for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",s+i,b+i); p[i]=p[i-1]+b[i]; &#125; for(int l=2;l&lt;=n;l++) &#123; for(int i=1,j;(j=i+l-1)&lt;=n;i++) &#123; if(i&lt;=c&amp;&amp;c&lt;=j)//如果不满足人在区间内显然不满足 &#123; f[i][j][0]=min ( f[i+1][j][0]+(s[i+1]-s[i])*(p[n]-p[j]+p[i]), f[i+1][j][1]+(s[j]-s[i])*(p[n]-p[j]+p[i]) ); f[i][j][1]=min ( f[i][j-1][1]+(s[j]-s[j-1])*(p[n]-p[j-1]+p[i-1]), f[i][j-1][0]+(s[j]-s[i])*(p[n]-p[j-1]+p[i-1]) ); &#125; &#125; &#125; cout&lt;&lt;min(f[1][n][0],f[1][n][1]); return 0;&#125; 区间dp–P4170 [CQOI2007]涂色传送门题目描述假设你有一条长度为5的木版，初始时没有涂过任何颜色。你希望把它的5个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为5的字符串表示这个目标：RGBGR。 每次你可以把一段连续的木版涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木版涂成RRRRR，第二次涂成RGGGR，第三次涂成RGBGR，达到目标。 用尽量少的涂色次数达到目标。 输入格式输入仅一行，包含一个长度为n的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。 输出格式仅一行，包含一个数，即最少的涂色次数。 输入输出样例输入 #1 复制AAAAA输出 #1 复制1输入 #2 复制RGBGR输出 #2 复制3说明/提示40%的数据满足：1&lt;=n&lt;=10 100%的数据满足：1&lt;=n&lt;=50 题解1.本题题意：区间内的涂色次数。这很明显！–区间dp。状态很好定义，就是f[i][j]表示从i到j的涂色次数。2.需要注意的是，本题要求的是最优解，但是涂色是以区间的形式，那么如果区间两端要求涂的颜色相同，就可以直接从两个子区间转移过来。如下 12345if(vi[i]==vi[j])&#123; f[i][j]=min(f[i][j],f[i+1][j]); f[i][j]=min(f[i][j],f[i][j-1]); &#125; 3.初始化每个区间长度为1的区间最小值都应该是14.状态转移方程，直接在i到j之间枚举一个k就行： 1234for(int k=i;k&lt;j;k++)&#123; f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);&#125; 5.附上AC代码+注释 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; #define maxn 105using namespace std;char vi[maxn];int len=0;int f[maxn][maxn];int main()&#123; cin&gt;&gt;vi; len=strlen(vi); memset(f,0x3f,sizeof(f)); for(int i=0;i&lt;len;i++) f[i][i]=1;//初始化 for(int l=2;l&lt;=len;l++)//区间长度 for(int i=0,j;(j=i+l-1)&lt;len;i++) &#123; if(vi[i]==vi[j]) &#123; f[i][j]=min(f[i][j],f[i+1][j]); f[i][j]=min(f[i][j],f[i][j-1]); &#125; else &#123; for(int k=i;k&lt;j;k++) &#123; f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]); &#125; &#125; &#125; cout&lt;&lt;f[0][len-1]; return 0;&#125; 区间dp–P3205 [HNOI2010]合唱队传送门题目描述为了在即将到来的晚会上有更好的演出效果，作为AAA合唱队负责人的小A需要将合唱队的人根据他们的身高排出一个队形。假定合唱队一共N个人，第i个人的身高为Hi米(1000&lt;=Hi&lt;=2000),并已知任何两个人的身高都不同。假定最终排出的队形是A 个人站成一排，为了简化问题，小A想出了如下排队的方式：他让所有的人先按任意顺序站成一个初始队形，然后从左到右按以下原则依次将每个人插入最终棑排出的队形中： -第一个人直接插入空的当前队形中。 -对从第二个人开始的每个人，如果他比前面那个人高(H较大)，那么将他插入当前队形的最右边。如果他比前面那个人矮(H较小)，那么将他插入当前队形的最左边。 当N个人全部插入当前队形后便获得最终排出的队形。 例如，有6个人站成一个初始队形，身高依次为1850、1900、1700、1650、1800和1750, 那么小A会按以下步骤获得最终排出的队形： 1850 1850 , 1900 因为 1900 &gt; 1850 1700, 1850, 1900 因为 1700 &lt; 1900 1650 . 1700, 1850, 1900 因为 1650 &lt; 1700 1650 , 1700, 1850, 1900, 1800 因为 1800 &gt; 1650 1750， 1650, 1700，1850, 1900, 1800 因为 1750 &lt; 1800 因此，最终排出的队形是 1750，1650，1700，1850, 1900，1800 小A心中有一个理想队形，他想知道多少种初始队形可以获得理想的队形 输入格式无 输出格式注意要mod19650827 输入输出样例输入 #1 复制41701 1702 1703 1704输出 #1 复制8说明/提示30%的数据：n&lt;=100100%的数据：n&lt;=1000 题解1.区间求解，确定区间dp策略2.该题同样需要注意区间的左右3.状态转移+讲解：f[i][j][0/1]0/1表示左右，状态定义：从i到j的方案数如 f[i][j][0]:就是指当前插入的人在左边时 区间i 到 j的方案数 1234f[i][j][0]=f[i+1][j][0]*(h[i]&lt;h[i+1])%mod+f[i+1][j][1]*(h[i]&lt;h[j])%mod;//在从子区间进行转移时候，需要通过身高来判断是否可以进行转移//括号就相当于进行了一次逻辑运算f[i][j][1]=f[i][j-1][0]*(h[j]&gt;h[i])%mod+f[i][j-1][1]*(h[j]&gt;h[j-1])%mod; 初始化： 123memset(f,0,sizeof(f));//每个区间先初始化为零for(int i=1;i&lt;=n;i++) f[i][i][0]=1;//默认每个人都先站在左边 4.附上AC代码+注释 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define maxn 1005using namespace std;const int mod = 19650827;int f[maxn][maxn][2];int n;int h[maxn];int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) scanf("%d",h[i]); for(int i=1;i&lt;=n;i++) f[i][i][0]=1; for(int l=2;l&lt;=n;l++)//区间长度 &#123; for(int i=1,j;(j=i+l-1)&lt;=n;i++) &#123; f[i][j][0]=f[i+1][j][0]*(h[i]&lt;h[i+1])%mod+f[i+1][j][1]*(h[i]&lt;h[j])%mod; f[i][j][1]=f[i][j-1][0]*(h[j]&gt;h[i])%mod+f[i][j-1][1]*(h[j]&gt;h[j-1])%mod; &#125; &#125; cout&lt;&lt;(f[1][n][0]+f[1][n][1])%mod; return 0;&#125; 区间dp–P4302 [SCOI2003]字符串折叠传送门题目描述折叠的定义如下： 一个字符串可以看成它自身的折叠。记作S = SX(S)是X(X&gt;1)个S连接在一起的串的折叠。记作X(S) = SSSS…S(X个S)。如果A = A’, B = B’，则AB = A’B’ 例如，因为3(A) = AAA, 2(B) = BB，所以3(A)C2(B) = AAACBB，而2(3(A)C)2(B) = AAACAAACBB给一个字符串，求它的最短折叠。例如AAAAAAAAAABABABCCD的最短折叠为：9(A)3(AB)CCD。 输入格式仅一行，即字符串S，长度保证不超过100。 输出格式仅一行，即最短的折叠长度。 输入输出样例输入 #1 复制NEERCYESYESYESNEERCYESYESYES输出 #1 复制14说明/提示一个最短的折叠为：2(NEERC3(YES)) 题解1.算法思路（1）dp核心：看到区间求解会顺理成章的想到区间dp，将问题转换成多个子问题求解根据区间dp通过子问题求解的特性我们可以写出换与不换两种dp方程，如下 1234//k是区间i到j中间枚举出的一个点dp[i][j]=min(dp[i][j],dp[i][k]+2+solve(l/(k-i+1)));//2是括号的长度，solve是用来求系数的长度，比如系数为39，solve就会返回2dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);//直接通过子问题转移求解 这里我们需要注意的是不一定折叠了就会更优，如 aaa折叠为3（a）就会更长（2）check：我们的第一个dp的使用是有条件的———能够折叠所以在dp过程中我们需要先check一下能否折叠 1234567891011int check(int x1,int y1,int x2,int y2)&#123; if((y2-x1+1)%(y1-x1+1)!=0) return 0;//判断能否被折叠成这个长度为y1-x1+1的片段 int h=y1-x1+1;//将要折叠成为的长度 for(int i=x2;i&lt;=y2;i++) &#123; if(v[i]!=v[i-h]) return 0; //这里其实还是有一些投机的，不需要改变数组初始位置以及取模来与第一个模板比较，而是可以层层check &#125; return 1;//如果可以就return true&#125; （3）dp初始化：这是一个很重要的细节点，单列一波。因为求小，先直接memset为较大数。然后因为每个区间长度唯一的dp数组都在开始一定为1（因为只一个字符嘛）然后dp[i][j]因为表示的是从i到j的区间内的字符串最短长度，所以应该初始化为初始的字符串长度，即j-i+1 2.附上AC代码+注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define maxn 105#define ll long long int using namespace std;char v[maxn];int dp[maxn][maxn];int check(int x1,int y1,int x2,int y2)&#123; if((y2-x1+1)%(y1-x1+1)!=0) return 0; int h=y1-x1+1; for(int i=x2;i&lt;=y2;i++) &#123; if(v[i]!=v[i-h]) return 0; &#125; return 1;&#125;int solve(int k)&#123; int su=0; while(k) &#123; su++; k/=10; &#125; return su;&#125;int get[105];int len;int main()&#123; memset(dp,0x3f,sizeof(dp)); cin&gt;&gt;v; len =strlen(v); for(int i=0;i&lt;len;i++) dp[i][i]=1; for(int l=2;l&lt;=len;l++) &#123; for(int i=0,j;( j=l+i-1)&lt;len;i++) &#123; dp[i][j]=j-i+1; for(int k=i;k&lt;j;k++) &#123; k-i+1; if(check(i,k,k+1,j)) &#123; dp[i][j]=min(dp[i][j],dp[i][k]+2+solve(l/(k-i+1))); &#125; else &#123; dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);//这里也可以拿出去，不过更加麻烦 &#125; &#125; &#125; &#125; cout&lt;&lt;dp[0][len-1]; return 0;&#125; dp杂题–POJ2663 UVA10918Tri Tiling传送门翻译：描述 有多少种方法可以用2x1多米诺骨牌拼贴3xn矩形？这是一个3x12矩形的样本平铺。 输入 输入包含几个测试用例，后跟一行包含-1。每个测试用例是包含整数0 &lt;= n &lt;= 30的行。产量 对于每个测试用例，输出一个整数，给出可能的倾斜次数。样本输入 2812-1样本输出 31532131 题解1.想必各位都有做骨牌问题的经验，即划分问题，分而治之。2.算法思想：（1）由骨牌我们很容易可以想到，倒推寻找满足的子问题。不难得到dp式： dp[i]=(dp[i-2]+dp[i-4]+………dp[2])2+dp[i-2]+2;(dp[i-2]+dp[i-4]+………dp[2])2:最后的长方形大致呈这样：dp[i-2]：加2是因为要考虑n==0时，我们是默认没有情况也算作一种情况的不好叙述，上代码注释吧 123456789101112131415161718192021222324252627282930ll solve2(int x)&#123; ll ans=0;//计数器 int k=x; while(k) &#123; k=k-2; if(k&lt;1) break; ans+=dp[k]; &#125; ans*=2; if(x&gt;=3) ans+=dp[x-2]; return ans;&#125;int flag=1;void solve1()&#123; dp[2]=3;//初始化 dp[4]=11; for(int i=6;i&lt;=32;i++) &#123; if(i%2==1)//如果是一个奇数乘以奇数的表格一定不能由偶数面积的长方形拼成 continue; dp[i]=solve2(i);//如果有值进行函数进行处理 dp[i]+=2; &#125; flag=0;&#125; 2.附上AC代码+注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define maxn 1005#define ll long long int using namespace std;int n;ll dp[maxn];int num=0;ll solve2(int x)&#123; ll ans=0; int k=x; while(k) &#123; k=k-2; if(k&lt;1) break; ans+=dp[k]; &#125; ans*=2; if(x&gt;=3) ans+=dp[x-2]; ans+=2; return ans;&#125;int flag=1;void solve1()&#123; dp[2]=3; dp[4]=11; for(int i=6;i&lt;=32;i++) &#123; if(i%2==1) continue; dp[i]=solve2(i); &#125; flag=0;&#125;int main()&#123; dp[0]=1; while(1) &#123; cin&gt;&gt;n; if(n==-1) break; if(flag)//这里因为题目要求是多组数据，所以使用了一点记忆化的小技巧 solve1(); cout&lt;&lt;dp[n]&lt;&lt;endl; &#125; return 0;&#125; dp杂题–数塔问题1.简单例题：数塔问题(Hdu_oj2084)DP数塔Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 70797 Accepted Submission(s): 40982Problem Description在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的： 有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？ 已经告诉你了，这是个DP的题目，你能AC吗? Input输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。 Output对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。 Sample Input1573 88 1 02 7 4 44 5 2 6 5 Sample Output30 Source2006/1/15 ACM程序设计期末考试 题解 1.dp入门题。 2.非dp思路： 其实本题有很多的方法，这里先简单叙述一下不用dp的方法 例： （1）贪心。当然纯粹的贪心是不能过的，因为贪心会破坏对应的无后效性，那么一次贪心不行我们就贪个一万次，嘛，每次寻找最优解。 （2） 深搜。时间复杂度：2 ^ n； 以上两种算法不一定能够满分，数据如果比较强，那就需要dpd了 （3）随机数法。因为该题是多组数据，所以概率就大打折扣了 该方法代码： 12345678910111213141516int result=0; srand(time(NULL)); for(int t=1;t&lt;=10000;t++) &#123; int x=0; int v=0; for(int i=1;i&lt;=n;i++) &#123; double p=(double)rand()/(double)RAND_MAX; if(p&lt;0.5) x+=0; else x+=1; v+=a[i][x]; &#125; if(v&gt;result) result=v; &#125; //随机大法 （4）这里简绍一种求最小值的算法：深搜。当然纯粹的深搜也是不能过的，因为深搜会带来2 ^ n的时间复杂度，所以我们可以通过剪枝来优化。那怎么剪枝呢？goodquestion。我们可以先简单贪心一两次，找到一组较小的合法的解。然后在深搜的过程中，如果我们当前得到的答案已经大于贪心的解了，就直接return3.dp大法（1）定义dp状态：dp[i][j] 表示位置为的i ，j的点从底部到该点的最大和（2）dp方程a数组是用来存图 1f[i][j]=max(f[i+1][j],f[i+1][j+1])+a[i][j]; 表示从自区间一层一层dp来获得最优解这里需要注意的是我们for循环中i的顺序是逆推还是正推。逆推： 从底下向上找最优解，我们可以dp完了之后直接输出 dp[1][1]顺推：从上到下进行寻找，得到的最优解就存在于最底部，我们就需要在遍历最底层寻找一下最大值核心代码如下逆推： 12345678for(int i=n;i&gt;=1;i--) &#123; for(int j=1;j&lt;=i;j++) &#123; f[i][j]=max(f[i+1][j],f[i+1][j+1])+a[i][j]; &#125; &#125; cout&lt;&lt;f[1][1];//逆推 顺推： 12345678910111213for(int i=1;i&lt;=n;i--)&#123; for(int j=1;j&lt;=i;j++) &#123; f[i][j]=max(f[i+1][j],f[i+1][j+1])+a[i][j]; &#125;&#125;int ans=-10;for(int i=1;i&lt;=n;i++)&#123; if(ans&lt;f[n][i]) ans=f[n][i];&#125;cout&lt;&lt;ans;//顺推 4.附上AC代码+注释 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#define maxn 105using namespace std;int a[maxn][maxn],f[maxn][maxn];int t; int n;int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; f[n][i]=a[n][i]; &#125; for(int i=n;i&gt;=1;i--) &#123; for(int j=1;j&lt;=i;j++) &#123; f[i][j]=max(f[i+1][j],f[i+1][j+1])+a[i][j];//由子区间dp &#125; &#125; cout&lt;&lt;f[1][1]&lt;&lt;endl;//逆推 &#125; return 0;&#125; 2.在该题原条件下输出路径g数组是一个标记数组表示在路径上一点的下一层是经过左边还是右边 12345678910void path(int i,int j)&#123; if(i==0||j==0) return ; else if(g[i][j]==1) path(i-1,j); else path(i-1,j-1); cout&lt;&lt;a[i][j]&lt;&lt;" ";&#125; 12345678910111213141516171819int ans,p;for(int i=1;i&lt;=n;i++)&#123; ans=p=0; for(int j=1;j&lt;=i;j++) &#123; f[i][j]=f[i-1][j]+a[i][j]; g[i][j]=1; if(f[i][j]&gt;f[i-1][j-1]+a[i][j]) &#123; f[i][j]=f[i-1][j-1]+a[i][j] g[i][j]=2; &#125; if(result&gt;f[i][j]) result=f[i][j],p=j; &#125; &#125;path(n,p); //打印路劲 cout&lt;&lt;result; 3.进阶题目（1）原条件不变，将求解目标改为路径和的个位数最大求解目标改变会带来dp状态的改变。换汤不换药。但是如果还是按照以前的方法处理进位就会造成错误。所以面对更加棘手的题目，我们可以升维度，来降难度。dp[i][j][k]（1&lt;=k&lt;=9） 定义： 坐标为（i，j）的点可以/不可以产生个位数为k的和，可以就标记为true上代码dp： 123456789if((a[i][j]+t)%10==k)//如果可以构成k&#123; if(dp[i+1][j][t]==true||dp[i+1][j+1][t]==true) //如果子树能够提供t这个常数，那么就可以让该点的dp[][][k]变为true &#123; dp[i][j][k]=true; &#125; &#125; AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//求三角形路劲和的个位数最大值 #include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#define maxn 100using namespace std;bool dp[maxn][maxn][11];int a[maxn][maxn];int n;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; dp[n][i][a[n][i]%10]=true; &#125; for(int i=n;i&gt;=1;i--) &#123; for(int j=1;j&lt;=i;j++) &#123; for(int k=0;k&lt;=9;k++) &#123; for(int t=0;t&lt;=9;t++)//这里的循环可以直接剪掉，各位自己实现吧 &#123; if((a[i][j]+t)%10==k) &#123; if(dp[i+1][j][t]==true||dp[i+1][j+1][t]==true) &#123; dp[i][j][k]=true; &#125; &#125; &#125; &#125; &#125; &#125; for(int i=9;i&gt;=0;i--) &#123; if(dp[1][1][i]) &#123; cout&lt;&lt;i; break; &#125; &#125; return 0;&#125; （2）求解目标不变，条件改变为其中某一个点，可以到下一层的任意一个点，并且这个点坐标未知，求最大路径和后效性改变—升维为了方便，我们称那个特殊点为x点dp方程：dp[i][j][0/1]：坐标为（i，j）的点的最优解，0表示该条路径已经遍历到了的地方没有x点，1表示该点或该条路径上有x点。max[i]：存第i层的每个d[i][][0]当中的最大值，方便处理x点的计算 12d[i][j][0]=max(d[i+1][j][0],d[i+1][j+1][0]);d[i][j][1]=max(d[i+1][j][1],max(d[i+1][j+1][1],max[i+1])); 核心代码： 123456789101112131415memset(max,0,sizeof(max));for(int i=1;i&lt;=n;j++)&#123; d[n][i][1]=d[n][i][0]=a[n][i]; if(a[n][i]&gt;max[n]) max[n]=a[n][i];&#125; for(int i=n-1;i&gt;=1;i--)&#123; for(j=1;j&lt;=i;j++) &#123; d[i][j][0]=max(d[i+1][j][0],d[i+1][j+1][0]); if(d[i][j][0]&gt;max[i]) max[i]=d[i][j][0]; d[i][j][1]=max(d[i+1][j][1],max(d[i+1][j+1][1],max[i+1])); &#125;&#125; conclusion** 升维度思考：遇到棘手问题，考虑后效性**** 降维度思考：考虑空间换时间 **]]></content>
      <categories>
        <category>NOIPLearning</category>
      </categories>
      <tags>
        <tag>only for her</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP--知识点+多道例题]]></title>
    <url>%2F2019%2F08%2F29%2FKMP-%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%A4%9A%E9%81%93%E4%BE%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.算法介绍KMP是经典得不能再经典的字符串查找算法。它用来对字符串查找时的时间复杂度的优化，通过预处理减少大部分没必要计算的问题。 2.算法正题比如A：aaabsaabssb lena=11;B：bssb lenb=4;以下数组下标从1开始（1）.一般暴力方法：我们一个一个查找。先声明两个指针变量i，j。如果A[i+1]==B[j+1]，就i++，j++；如果不是，就j=1，i=i-lenb+1；这段代码的意思就是，我们一个一个枚举母串的起点。显然这样的算法是十分费时的，我们就可以通过KMP来减少处理的次数。（2）正题：KMP1.思想：在我们发现A[i+1]!=B[j+1]时，我们的暴力算法是需要我们再从头到尾扫一遍。很明显不用这样就浪费了我们前面做出的努力。易得：我们的求解b[1…..j]要跟我们的A[i-j+1………i]完全相等。当A[i+1]!=B[j+1]，我们就需要对j做出改变。那么问题来了，我们的j变为多少呢？goodquestion。这就是KMP的核心了。举例：比如B：acbacaba A：acbacbacbacaba当j=5，i=5；A[i+1]!=B[j+1]；我们就可以将j变为2而不是0；这样就会减少j变为1的更多运算。很显然：我们得到的j’，就是一个该字符串的最大相等前缀和后缀比如： abab ：j’=2 abbbcdabbbc ：j’=5我们直接预处理出一个j’数组，在程序运行直接获得就好。2.预处理数组实现（这是一个在KMP中很重要的点）：求p[j’]数组：表示没能够匹配，j将要变成的值原理：B :ababacd已经知道p[1-4] ,我们来寻找一下p[5],p[6];p[1]=0;p[2]=0;p[3]=1;p[4]=2;因为p[4]=2&amp;&amp;B[3]=B[5]所以p[5]=p[4]+1;p[6]?貌似很棘手啊我们来想一下p数组的性质，它是用来存储最大相等前缀和后缀的。求解p[j]我们应该遍历已经找到的p[j’],根据p[5]=p[4]+1,很多人会想，p[j]=p[j’]+1 &amp;&amp;j’=j-1?这个等式的成立是有条件的，即B[p[j’]]=B[j]比如 abcabc 如果要达到p[6]=p[5]+1,就需要达到B[6]=B[3].想到这里问题就比较明朗了，比如找p[6],如果p[5]不能取，那么我们就找p[p[5]].一直找到1为止 1234567891011void pre()&#123; p[1]=0; int j=0; for(int i=1;i&lt;len2;i++) &#123; while(j&gt;=1&amp;&amp;b[i+1]!=b[j+1]) j=p[j]; if(b[i+1]==b[j+1]) j++;//能够匹配了，我们就加上已经匹配好的B[i+1] p[i+1]=j; &#125;&#125; 3.KMP内容有了神器P数组的帮助，我们求解内容其实就跟暴力差不多了，只是在改变j的时候改为P[j]就好。 1234567891011121314void kmp()&#123; int j=0; for(int i=0;i&lt;len1;i++) &#123; while(j&gt;=1&amp;&amp;a[i+1]!=b[j+1]) j=p[j];//不能匹配，再次寻找 if(a[i+1]==b[j+1]) j++; if(j==len2) &#123; cout&lt;&lt;i-j+2&lt;&lt;endl; j=p[j];//继续寻找匹配的 &#125; &#125;&#125; 可以发现的是，这一段代码和上一段代码相似度很高。因为它们两个都是一个寻找匹配的过程，所以大致相同的3.例题详解 （1）P3375模板题传送门题目描述如题，给出两个字符串s1和s2，其中s2为s1的子串，求出s2在s1中所有出现的位置。 为了减少骗分的情况，接下来还要输出子串的前缀数组next。 （如果你不知道这是什么意思也不要问，去百度搜[kmp算法]学习一下就知道了。） 输入格式第一行为一个字符串，即为s1 第二行为一个字符串，即为s2 输出格式若干行，每行包含一个整数，表示s2在s1中出现的位置 接下来1行，包括length(s2)个整数，表示前缀数组next[i]的值。 输入输出样例输入 #1 复制ABABABCABA输出 #1 复制130 0 1说明/提示时空限制：1000ms,128M 数据规模： 设s1长度为N，s2长度为M 对于30%的数据：N&lt;=15，M&lt;=5 对于70%的数据：N&lt;=10000，M&lt;=100 对于100%的数据：N&lt;=1000000，M&lt;=1000000 样例说明： 所以两个匹配位置为1和3，输出1、3 题解这是一道很基础的模板题，直接上模板就可以了附上AC代码+注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define maxn 1000050using namespace std;char a[maxn];char b[maxn];int p[maxn];int len1,len2;void pre()&#123; p[1]=0; int j=0; for(int i=1;i&lt;len2;i++) &#123; while(b[j+1]!=b[i+1]&amp;&amp;j&gt;0) j=p[j]; if(b[i+1]==b[j+1]) j++; p[i+1]=j; &#125;&#125;void kmp()&#123; int j=0; for(int i=0;i&lt;len1;i++) &#123; while(j&gt;0&amp;&amp;b[j+1]!=a[i+1]) j=p[j]; if(a[i+1]==b[j+1]) j++; if(j==len2) &#123; cout&lt;&lt;i-j+2&lt;&lt;endl; j=p[j]; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;a+1; //表示字符串首部是a[1] scanf("%s",b+1); len1=strlen(a+1); len2=strlen(b+1); pre(); kmp(); for(int i=1;i&lt;=len2;i++) cout&lt;&lt;p[i]&lt;&lt;" "; cout&lt;&lt;endl; return 0;&#125; （2）P4391传送门题目描述给你一个字符串，它是由某个字符串不断自我连接形成的。 但是这个字符串是不确定的，现在只想知道它的最短长度是多少. 输入格式第一行给出字符串的长度,1 &lt; L ≤ 1,000,000. 第二行给出一个字符串，全由小写字母组成. 输出格式输出最短的长度 输入输出样例输入 #1 复制8cabcabca输出 #1 复制3说明/提示对于样例,我们可以利用”abc”不断自我连接得到”abcabcabc”,读入的cabcabca,是它的子串 个人意见：将“abc”改成“cab” 题解1.分析此题做法还是有一点投机的。有关子母字符串，很容易让人想到KMP算法，此题也正是使用这种方法。p[]:定义字符串b的最大相等前缀和后缀。x:求解目标，最小子串分析一下样例，很明显 ：p[x]=0；p[x+1]=x+1-x=1;p[n]=n-x;所以我们就可以根据这个很容易地求到n-p[n]=x;2.附上AC代码+注释 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define maxn 1000050using namespace std;char b[maxn];int p[maxn];int len;void pre()&#123; int j=0; p[1]=0; for(int i=1;i&lt;len;i++) &#123; while(j&gt;=1&amp;&amp;b[i+1]!=b[j+1]) j=p[j]; if(b[i+1]==b[j+1]) j++; p[i+1]=j; &#125;&#125;int main()&#123; cin&gt;&gt;len; cin&gt;&gt;b+1;//字符串首为b[1]; pre();//计算p cout&lt;&lt;len-p[len]; return 0;&#125; （3）P3435 [POI2006]OKR-Periods of Words传送门 题目描述A string is a finite sequence of lower-case (non-capital) letters of the English alphabet. Particularly, it may be an empty sequence, i.e. a sequence of 0 letters. By A=BC we denotes that A is a string obtained by concatenation (joining by writing one immediately after another, i.e. without any space, etc.) of the strings B and C (in this order). A string P is a prefix of the string !, if there is a string B, that A=PB. In other words, prefixes of A are the initial fragments of A. In addition, if P!=A and P is not an empty string, we say, that P is a proper prefix of A. A string Q is a period of Q, if Q is a proper prefix of A and A is a prefix (not necessarily a proper one) of the string QQ. For example, the strings abab and ababab are both periods of the string abababa. The maximum period of a string A is the longest of its periods or the empty string, if A doesn’t have any period. For example, the maximum period of ababab is abab. The maximum period of abc is the empty string. Task Write a programme that: reads from the standard input the string’s length and the string itself,calculates the sum of lengths of maximum periods of all its prefixes,writes the result to the standard output. 一个串是有限个小写字符的序列,特别的,一个空序列也可以是一个串. 一个串P是串A的前缀, 当且仅当存在串B, 使得 A = PB. 如果 P A 并且 P 不是一个空串,那么我们说 P 是A的一个proper前缀. 定义Q 是A的周期, 当且仅当Q是A的一个proper 前缀并且A是QQ的前缀(不一定要是proper前缀). 比如串 abab 和 ababab 都是串abababa的周期. 串A的最大周期就是它最长的一个周期或者是一个空串(当A没有周期的时候), 比如说, ababab的最大周期是abab. 串abc的最大周期是空串. 给出一个串,求出它所有前缀的最大周期长度之和.。 输入格式In the first line of the standard input there is one integer kk (1\le k\le 1\ 000\ 0001≤k≤1 000 000) - the length of the string. In the following line a sequence of exactly kk lower-case letters of the English alphabet is written - the string. 输出格式In the first and only line of the standard output your programme should write an integer - the sum of lengths of maximum periods of all prefixes of the string given in the input. 输入输出样例输入 #1 复制8babababa输出 #1 复制24题解1.分析先翻译一下这道让人无法看懂的题。给出一个数组，长度为n。你需要对它的n个前缀进行操作操作：比如现在我们需要操作前缀i。你需要找出该i字符串的最大周期。并且把n个前缀的最大周期的值加起来。既然需要加上最大周期，那么怎么求最大周期呢？如图，每个字符串都可以分为三个小字符串，我们称为1,2,3号；（从左往右的顺序）当1号3号完全相等时，1和2，或者2和3就构成了一个周期；最大：也就是1和3越小时周期T就会越大根据前后相等的性质（1号和3号），我们很自然就想到了KMP中的next数组（我习惯用p数组来表示）。那么怎么求最小呢，我们一直递归下去就好了放一段伪代码吧； 12345678910111213ll print()&#123; for(int i=1;i&lt;=n;i++) &#123; int j=i; while(next[j]) j=next[j]; ans+=i-j; if(next[i]) next[i]=j; //这里是一个优化，相当于以后我在访问next[i]，可以一步到位，有点像并查集的优化 //如果这里不优化的化应该会有60分 &#125; return ans;&#125; 2.附上AC代码+注释 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define maxn 1000005#define ll long long int using namespace std;int n;char a[maxn];int next[maxn];void pre()&#123; next[1]=0; int j=0; for(int i=1;i&lt;n;i++) &#123; while(j&gt;=1&amp;&amp;a[i+1]!=a[j+1]) j=next[j]; if(a[i+1]==a[j+1]) j++; next[i+1]=j; &#125;&#125;ll ans=0;ll print()&#123; for(int i=1;i&lt;=n;i++) &#123; int j=i; while(next[j]) j=next[j]; ans+=i-j; if(next[i]) next[i]=j; &#125; return ans;&#125;int main()&#123; cin&gt;&gt;n; cin&gt;&gt;a+1;//数组首项从a[1]开始 pre(); cout&lt;&lt;print(); return 0;&#125;]]></content>
      <tags>
        <tag>only for her</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集 learning]]></title>
    <url>%2F2019%2F08%2F07%2F%E5%B9%B6%E6%9F%A5%E9%9B%86-learning%2F</url>
    <content type="text"><![CDATA[并查集基础知识+一个水模板1.其实并查集无非就是两个思想 ： 并和查2.那么我们为什么要进行并和查呢，这样做有什么作用呢下面给出一道基础模板题题意： 多个黑帮混战，但是由于都光着膀子，并且每个人只认识自己的师父（每个黑帮祖师爷只认识自己，毕竟目中无人嘛！）。现在有两个人碰在一起，但是他们不知道对方是敌人还是一个帮派的，请你来告诉他们（祖师爷一样就代表是同一个黑帮） 样例输入：n，m n代表一共n个人，m代表一共m个师徒关系 接下来m行，每行两个整数，第一个整数代表徒弟的编号，第二个代表他的师父 接下来输入x，y请判断x和y是不是同一个黑帮的呢 样例输出：yes or no如题意：1.每个团伙是不是都有一个祖师爷，如果我们取一个数组pre【n+5】来存下每个人的祖师爷，那我们最后是不是只用看看x和y的祖师爷相不相同就行了呢；2.每次输入都将徒弟和师傅并成一个集合，并将徒弟的祖师爷变成师傅的祖师爷；这里要特别强调一点，我们的pre【】数组在初始化的时候都要初始化成自己，因为在师徒关系未确定前，徒弟的祖师爷就是自己。同时在并集合的时候我们需要查一下徒弟和师傅的祖师爷是否相同，如果相同就不用并了下面给出核心并/查代码查： 123456789int find (int x)//定义成int类型是因为我们需要返回祖师爷的编后&#123; int r=x; while(r!=pre[r])//因为每个祖师爷的师傅都是自己 //所以当我们搜到人上面还有师傅且不是自己的时候，我们就继续搜索下去 r=pre[r]; return r;&#125;//优化后续呈现 并 1234567891011void join(int x,int y)&#123; int kx=find(x); int ky=find(y); if(kx!=ky)//如果这两个人的祖师爷不同，那说明这两个人在不同集合，我们就需要合并 &#123; pre[x]=pre[y]; &#125; return//打上是个好习惯&#125;//在并这个地方并没有什么优化 P2078 朋友–并查集模板题传送门题目背景小明在A公司工作，小红在B公司工作。 题目描述这两个公司的员工有一个特点：一个公司的员工都是同性。 A公司有N名员工，其中有P对朋友关系。B公司有M名员工，其中有Q对朋友关系。朋友的朋友一定还是朋友。 每对朋友关系用两个整数(Xi,Yi)组成，表示朋友的编号分别为Xi，Yi。男人的编号是正数，女人的编号是负数。小明的编号是1，小红的编号是-1. 大家都知道，小明和小红是朋友，那么，请你写一个程序求出两公司之间，通过小明和小红认识的人最多一共能配成多少对情侣。（包括他们自己） 输入输出格式输入格式：第1行，4个空格隔开的正整数N,M,P,Q。 之后P行，每行两个正整数Xi，Yi。 之后Q行，每行两个负整数Xi，Yi。 输出格式：一行，一个正整数，表示通过小明和小红认识的人最多一共能配成多少对情侣。（包括他们自己） 输入输出样例输入样例#1：4 3 4 21 11 22 31 3-1 -2-3 -3输出样例#1：2说明对于30%数据，N,M&lt;=100，P,Q&lt;=200 对于80%数据，N,M&lt;=4000,P,Q&lt;=10000. 对于全部数据，N,M&lt;=10000,P,Q&lt;=20000。 题解此题很明显，因为一个公司只有一个性别，所以只能通过小明小红来连接，显然需要使用并查集不过此题的数据范围是一个问题，需要使用查的优化（代码中会提到），其次该输入数据有负数，需要使用一点小技巧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;using namespace std;int n,m,p,q;int pre[20005];int w[20005],u[20005],v[40005],c[40005];int find (int x)&#123; int r=x; while(r!=pre[r]) &#123; r=pre[r]; &#125; int l=x,j; //接下来的优化可以达到一次调整的作用，在下一次find的时候可以直接得到祖先，方便否？ while(l!=r) &#123; j=pre[l]; pre[l]=r;//在扫的过程中将每个的祖先直接改为根祖先，为下次遍历降低了时间 l=j; &#125; return r;//返回找到的祖先&#125;void join(int x,int y)&#123; int kx=find(x); int ky=find(y); if(kx!=ky) &#123; pre[kx]=ky; &#125;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;q); for(int i=1;i&lt;=n+m+5;i++) pre[i]=i;//初始化father数组，每个人的祖先一开始都是自己 for(int i=1;i&lt;=p;i++) &#123; scanf("%d%d",&amp;w[i],&amp;u[i]);//此题因为时间限制，如果使用cin不加快必定超时，当然最方便的肯定是scanf if(find(w[i])!=find(u[i])) join(w[i],u[i]);//将二者加入一个集合 &#125; for(int i=n+1;i&lt;=n+q;i++) &#123; scanf("%d%d",&amp;v[i],&amp;c[i]); v[i]=-v[i]+n;//取相反数，再加上n，就可以避免数组下标为负数的尴尬 c[i]=-c[i]+n; join(v[i],c[i]); &#125; int ans1=0; int ky=find(1); for(int i=1;i&lt;=n;i++)//这里为什么是从1开始而不是2（避开祖先）呢，因为题目中有说包括小明和小红 &#123; if(ky==find(i)) ans1++; &#125; int ans2=0; int kx=find(n+1); for(int i=1+n;i&lt;=n+m;i++) &#123; if(kx==find(i)) ans2++; &#125; ans1=min(ans1,ans2);//总不可能一夫多妻或者一妻多夫吧 cout&lt;&lt;ans1; return 0;&#125;]]></content>
      <tags>
        <tag>only for her</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[课题--细析费马小定理--ZOJ3785，P2842]]></title>
    <url>%2F2019%2F07%2F28%2F%E8%AF%BE%E9%A2%98-%E7%BB%86%E6%9E%90%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86-%E4%BB%8E%E6%87%82%E5%88%B0%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[0.写在前面在学习费马小定理之前，需要掌握一些数论基本知识 (0).≡-这个符号指的是左右两边的数对p求模结果相同。这里不需要太过纠结，就当做有特殊意义的等号吧。 （1）.同余同余就是指 当 c能够整除（a-b） 时，我们就称 a,b关于模 c同余 记作： （a-b）≡0（mod c）,a≡b(mod c)-补充几个性质（仅作积累，在费马小定理作用不大）当 a≡ b（mod x） c≡ d (mod x)时;满足：1.(a+c)≡ (b+d)(mod x);2.ac≡bd(mod x);3.a-c≡ (b-d)(mod x); (2).逆元（解决数论中的除法）补充 ：数论中的加减乘（a+b）%c=(a%c+b%c)%c; (a-b)%c=(a%c-b%c)%c;ab%c=(a%cb%c)%c;假如题目中数据过大就可以步步取模防止溢出记得以前数学学习中的倒数吗。一个数除以另一个数，就相当于乘以这个数的倒数。在数论中：在取模的情况下，如果要求两个数相除，那么有有可能出现小数。这个时候我们就需要引入一个乘法逆元的概念： 当a*b≡ 1（mod p）时，我们就称 b是 a关于模p的逆元##注意##：（1）当p是一个素数时，则每个数都有唯一的确定的逆元。（2）当 a是b的逆元时，b也是a的逆元（3）0没有逆元（就像0没有倒数一样） 举例 当 p=5，a=2时； b=3； （3）筛法求素数（因为费马小定理的性质，所以判定是否为素数是必备的技能）-1.求素数用到的方法（1）普通枚举 枚举到sqrt（n）就好（2）朴素筛法通过对每个数有无非平凡因子来判断朴素筛法 nlogn ，这个时间复杂度的计算有些复杂如下n/2+n/3+n/4+…..+n/n;n(1/2+1/3+1/4+….+1/n)后面那一坨大致就约等于 ln（n） （学过数竞应该知道） 12345678910111213int a[maxn],b[maxn],n;int cnt=0;//筛出 2 到 n 中的所有素数 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//从i+i往后筛所有的倍数 a[j]=1; &#125;&#125; （3）埃式筛法通过素因子来筛 123456789101112131415int a[maxn],b[maxn],n;int cnt=0;//优化， nloglogn ，这里的计算跟上个差不多，埃式筛法 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) &#123; b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//将此循环体拿到if依据里面 //意思就是，在遍历筛的时候遇到的如果是合数就不用筛了，优化 a[j]=1; &#125; &#125;&#125; （4）线性筛（欧拉筛） 123456789101112131415void oula_sieve(int n)&#123; int cnt=0; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=a[i]; for(int j=0;b[j]*i&lt;=n;j++) &#123; a[b[j]*i]=1;// 保证b[j]是i*b[j]1的最小素因子 if(i%b[j]==0) break; &#125; &#125;&#125; 大家可能对以上三种方法及其优化思路还有疑问，下面加深讲解1.基本思想其实都是先筛掉有非平凡因数的合数筛掉，再进行存储2.举下面 一个栗子比如说我们要筛 12这个数（1）朴素筛 ： 除1外每个数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 ： 2 3 4 6（2）埃氏筛 ： 除1外每个质因数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 : 2 3 （3）欧拉筛 ：可能有人不太懂1–j代表的是下标2–b[]存储找到的素数代码中的第二重（if依据巧妙避开求重）可以让标记只让当前找到的素因数往后标记3–还是举12的例子12的最小质因数会将12筛出也就是只有：2 4–总结欧拉筛： 每次用已筛出来的质数去筛更大的数，每个合数只被它最小的质因子筛掉，试想，如果26筛了12之后还没break，而是用36筛掉18，那么18还会被29筛一次，就重复了而根本原因就是6有2这个因子，而36筛掉的数一定也有2这个因子，3*6这个数应该被2这个因子筛掉，而不是3 4.最大公约数–gcd（学会gcd是费马小定理前提）gcd（a，b）指的是a，的最大公约数如果a，b互质那么 gcd（a，b）=1；一般来讲我们求gcd是通过辗转相除法的就是 gcd(a,b)=gcd(a,b%a);满足a&gt;b这里直接套一个递归就好了 123456789101112int gcd(int a,int b)&#123; return b == 0 ? a : gcd(b,a % b);&#125;//这个玩意可以这么读：b == 0否?b == 0的话返回a,b != 0的话返回gcd(b,a%b)//就是辗转相除，除到0了那么上一个除数就是最大公约数int gcd(int a,int b)&#123; if(b==0) return a; return (b,a%b);&#125; 1.费马小定理（1）.内容：-同余式写法：当 gcd（p，a）=1 ，p是一个质数时；a^p − 1 =1(mod p);当a不能被素数p整除时，(a^p-1 )- 1一定能被p整除; (2).证明在各种证明方法中，同余的方法最为简单 （1）.特殊举例证明 任意取一个质数，比如13。考虑从1到12的一系列整数1,2,3,4,5,6,7,8,9,10,11,12，给这些数都乘上一个与13互质的数，比如3，得到3,6,9,12,15,18,21,24,27,30,33,36。对于模13来说，这些数同余于3,6,9,12,2,5,8,11,1,4,7,10。这些余数实际上就是原来的1,2,3,4,5,6,7,8,9,10,11,12，只是顺序不同而已。 把1,2,3,„,12统统乘起来，乘积就是12的阶乘12！。把3,6,9,„,36也统统乘起来，并且提出公因子3，乘积就是312×12！。对于模13来说，这两个乘积都同余于1,2,3,„,12系列，尽管顺序不是一一对应，即312×12！≡12！mod 13。两边同时除以12！得312≡1 mod 13。如果用p代替13，用x代替3，就得到费马小定理。 （2）一般化证明 取素数p，以及数列{ a，2a,3a,…………….,(p-1)a}； 这个数列中所有元素模p可以取遍1到p-1之间的所有数对于此句话的证明 反证法： 如果不满足，那么必有 k1a(mod p)=k2a(mod p)，并且满足1=&lt;k1&lt;=k2&lt;=p-1; 由此可得 (k1a-k2a)=0(mod p) 又因为 gcd（a,p）=1,所以k1-k2=0(mod p),再看范围，很明显错误 证毕 我们把数列中每个元素都乘起来，得到以下式子 a1a2a*3……a*(p-1)≡(p-1）!(mod p); 约掉（p-1）！ 就可以得到 a^p − 1 =1(mod p); (3).运用1.简单举例如果现在我们要去求 2^100（mod 13）=？很明显该数过大，不过我们首先可以考虑用二分的思想，一层一层取模运算。但是有没有更好的办法呢？肯定是有的从费马小定理出发，我们是否可以将这个一百化为 n*（p-1）+k，n直接用100/12向下取整就好了，这样的话，我们就直接考虑 2^4(mod 13)=? 2.快速求逆元我们对原式进行处理(a^p-2)*a=1(mod p);根据我们对逆元的定义，是否 a^p-2就是a关于p的逆元这里的求解，因为一般题目中的数据都是较大的，所以需要快速幂 补充一段快速幂算法代码 123456789101112131415161718192021222324int rapidmi(int x, int y)&#123; int result = 1; // 定义变量 while (y &gt; 0) // 当指数大于 0 时进行幂运算 &#123; if (y &amp; 1) // y 和 1 做与运算,相当于对 2 求模 &#123; result = result * x; // 如果 y 为奇数,则结果成一个 x &#125; x = x * x; // x 乘二次方,下次使用 y = y &gt;&gt; 1; // y 右移一位,相当于除以 2 &#125; return result; // 返回结果 &#125;int main()&#123; int x, y； while (scanf("%d %d", &amp;x, &amp;y)) &#123; printf("%d ^ %d = %d\n", x, y, rapidmi(x, y)); &#125; return 0;&#125; 给出一般用费马小定理求逆元(P3381会超时3个点)题目：输入 n,m;求出 n在模m意义下的逆元 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define maxn 3000003#define ll long long int using namespace std;int n,m;ll rapid(ll a,ll b)&#123; ll result=1; while(b&gt;0) &#123; if(b&amp;1)//相当取2的模 &#123; result=result*a; &#125; a*=a; b/=2; &#125; return result;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;rapid(n,m-2);//根据定义，就应该是 n的m-2次方 return 0;&#125; 3.两道列题ZOJ3785传送门 ZOJ3785题面来自谷歌翻译今天星期六，S.和L.一起出去游玩，突然S.提出一个问题1^1 + 2^2 + 3^3 + … + N^N天后的哪一天？L.一下子就解答了，你能吗？输入有多个测试用例。 第一行输入包含一个整数T，表示测试用例的数量。 对于每个测试用例： 只有一行包含一个整数N（1 &lt;= N &lt;= 1000000000）。 产量对于每个测试用例，输出一个表示星期几的字符串。 样本输入212样本输出SundayThursday暗示一周包括周日，周一，周二，周三，周四，周五和周六。Jīntiān xīngqíliù,11 + 22 + 33 +… + NN tiānhòu de nǎ yītiān? Shūrùyǒu duō gè cèshì yònglì. Dì yīxíng shūrù bāohán yīgè zhěngshù T, biǎoshì cèshì yònglì de shùliàng. Duìyú měi gè cèshì yònglì: Zhǐyǒu yī xíng bāohán yīgè zhěngshù N(1 &lt;= N &lt;= 1000000000). Chǎnliàngduìyú měi gè cèshì yònglì, shūchū yīgè biǎoshì xīngqí jǐ de zìfú chuàn. Yàngběn shūrù212yàngběn shūchūxīngqírìxīngqísìànshìyīzhōu bāokuò zhōu rì, zhōuyī, zhōu’èr, zhōusān, zhōu sì, zhōu wǔ hé zhōu liù. 题解Sabrina看到这道题有点感觉有点难了但是一旁的同学笑了笑，这是一道非常水的题，用上费马小定理秒杀哦！ 我们知道n^n%7= (n%7)^ n%7,令n%7=m，就相当于n-7[n/7]则原式=(m^ m%7)(m^ (n-m)%7)%7举个例子，9 ^9%7=2 ^9%7=((2 ^2%7)*(2 ^7%7)) %7，所以只要让(2 ^7%7)这个部分等于1，而且这一部分，2的幂肯定是7的倍数，那么循环节就出现了，循环节的开端为m ^m%7(m&lt;7)。我们知道(2 ^a%7) ^b%7=x ^ab%7，让该公式为1，且ab为7的倍数，则a等于6（费马小定理），得ab的最小值为42，也就是要重复就经过了42种情况，所以n^n%7的循环节为42 294=42*7,即为11 + 22 + 33 + … + NN %7的循环节但是Sabrina还是有一点疑惑，于是有了下面几张图 12345678910这个题中我们的p也就是一周的天数7，最开始的形式：1^1 2^2 3^3 4^4 5^5 6^6 7^78^8 9^9 10^10 11^11 12^12 13^13 14^1415^15 16^16 17^17 18^18 19^19 20^20 21^2122^22 23^23 24^24 25^25 26^26 27^27 28^2829^29 30^30 31^31 32^32 33^33 34^34 35^3536^36 37^37 38^38 39^39 40^40 41^41 42^4243^43 44^44 45^45 46^46 47^47 48^48 49^49 这里就相当于n-7*[n/7]的过程 费马小定理转化后–&gt;&gt;（分别取6的模，然后来减掉）1^1 2^2 3^3 4^4 5^5 6^0 0^11^2 2^3 3^4 4^5 5^0 6^1 0^21^3 2^4 3^5 4^0 5^1 6^2 0^31^4 2^5 3^0 4^1 5^2 6^3 0^41^5 2^0 3^1 4^2 5^3 6^4 0^51^0 2^1 3^2 4^3 5^4 6^5 0^01^1 2^2 3^3 4^4 5^5 6^0 0^1最后一行重复，循环节长度为42 （2）P2842 LJJ算数-传送门 题目描述LJJ刚上完了一节课！这节课是数学课！他知道了加减属于一级运算，乘除属于二级运算，幂则属于三级运算，而幂的优先级&gt;乘除的优先级&gt;加减的优先级（这是几年级的数学课）。但是，从上一套试卷+上一题中，我们知道了LJJ是一个总是突发奇想并且智商不够的人（也就是说他又想出一个问题给你咯）。他发明了一种四级运算，我们姑且用符号#来表示（找不到别的符号了）。我们知道ab=a+a+a+…+a(加b次)，a^b=aaaa…a(乘b次)，则a#b=a^a^a^a^…^a(进行幂运算b次)，自然，#的优先级比幂的优先级高。那么，LJJ就请你来帮他求a#b mod 1000000007咯。（PS:这是本试卷最简单的一道题） 输入格式输入仅1行，即a,b。 输出格式输出仅1行，即a#b mod 1000000007。 输入输出样例输入 #1 复制3 5输出 #1 复制968803245说明/提示首先说明，样例答案不mod其实是4.4342648824303776994824963061915e+38（来自出题人的恶意） 然后，数据范围： 对于20%的数据，a&lt;=1000,b&lt;=1000 对于50%的数据，a&lt;=10^16,b&lt;=10000 对于100%的数据，a&lt;=10^16,b&lt;=10^16 （1）.算法分析-本题的意思就是指 求 a的b幂次方也就是 （a） ^(a)^…将此式简化得到 a ^ (a) ^ (b-1)那么到了这个时候很明显就需要分两步来求解，一部分是 a ^ (b-1) 另一部分则是求 a^ (k)为了方便设 k=a ^ (b-1)； 1–第一部分的求解，因为b-1次方仍然过大，可以进一步取模根据费马小定理可以得到a ^ m (mod p)=a ^(m mod p-1 ) (mod p） 证明： a ^ m% p= a ^ (n(p-1) a^(m%(p-1))%p(次数相加，n指的是m/p-1向下取整)由费马小定理可以得到： a^ (n*(p-1))%p==1;所以： a^ m%p= a^(m%(p-1))%p;这里就是把 a^b-1看做m就好了证毕 2–第二部分：直接用第一部分的值，上快速幂就好 3–注意点，我们在快速幂的函数，要小心代表模大小的参数，因为，由式子可知，第一次是取得 q-1第二次取的是 q； （2）附上AC代码123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define maxn 3000003using namespace std;long long int n,m;const long long int modl = 1000000007;long long int rapidmi(long long int x,long long int y,long long int z)&#123; long long int result = 1; // 定义变量 x%=z; while (y &gt; 0) // 当指数大于 0 时进行幂运算 &#123; if (y &amp; 1) // y 和 1 做与运算,相当于对 2 求模 &#123; result = result * x%z; // 如果 y 为奇数,则结果成一个 x &#125; x = x * x%z; // x 乘二次方,下次使用 y = y &gt;&gt; 1; // y 右移一位,相当于除以 2 &#125; return result; // 返回结果 &#125;int main()&#123; int x, y; cin&gt;&gt;n&gt;&gt;m; long long int k=rapidmi(n,m-1,modl-1); long long int yo=rapidmi(n,k,modl); cout&lt;&lt;yo&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>NOIPLearning</category>
      </categories>
      <tags>
        <tag>2019课题 only for her</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题-POJ1852-P1367--思维题--详解]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%9A%82%E8%9A%81%E9%97%AE%E9%A2%98-POJ1852-P1367-%E6%80%9D%E7%BB%B4%E9%A2%98-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[POJ1852蚂蚁时间限制： 1000MS 内存限制： 30000K提交总数： 31489 接受： 11801描述 一队蚂蚁在长度为1厘米的水平杆上行走，每根杆的速度恒定为1厘米/秒。当一只行走的蚂蚁到达极的一端时，它会立即从它上掉下来。当两只蚂蚁相遇时，它们会转身并开始向相反方向行走。我们知道蚂蚁在杆子上的原始位置，不幸的是，我们不知道蚂蚁行走的方向。你的任务是计算所有蚂蚁从杆上掉下来所需的最早和最晚时间。输入 第一行输入包含一个整数，给出后面的案例数。每种情况的数据都以两个整数开始：极点长度（cm）和n，极点上的蚂蚁数量。这两个数字之后是n个整数，它们将杆上每只蚂蚁的位置作为从杆的左端测量的距离，没有特别的顺序。所有输入整数都不大于1000000，它们由空格分隔。产量 对于每种输入情况，输出由单个空格分隔的两个数字。第一个数字是所有蚂蚁从杆上掉下来的最早时间（如果他们的步行方向选择得恰当），第二个数字是最久可能的时间。样本输入 210 32 6 7214 711 12 7 13 176 23 191样本输出 4 838 207资源 滑铁卢当地人2004.09.19 题解1.算法思想我们·来看本题，直接对结果进行分析，是不是可以知道每个蚂蚁的最终的结果都是落了下来。其次题目中提到了，在两只蚂蚁相遇的过程中，两只蚂蚁会反向，首先我们的想法就是直接枚举，但是这样的时间复杂度显然是 2^n,不用想就要舍弃。既然是求最值，那么肯定跟贪心什么的有关系。回到蚂蚁反向的时刻，虽然蚂蚁反向了，但是两只蚂蚁的最终结果难道不都是掉下去了吗，并且两只蚂蚁并没有任何区别，那么我们可不可以看做两只蚂蚁并未反向，而是进行了灵魂交换。。。？想到这里问题就很明朗了，通过贪心的策略，对于每一只蚂蚁而言，最长时间就是朝向离自己最远的一端，最近时间就是朝向离自己最近的一端。直接套上一个循环然后求最值即可；2.核心代码讲解 12345678910int lmi=0,lmx=0; for(int i=1;i&lt;=m;i++) &#123; lmi=max(lmi,min(a[i],n-a[i])); //动态求最小值 //因为是时间，所以要满足时间最长的蚂蚁能够掉下去，所以要在原最小值和现最小值间取最大值 lmx=max(lmx,max(a[i],n-a[i])); //同理 &#125; cout&lt;&lt;lmi&lt;&lt;" "&lt;&lt;lmx&lt;&lt;endl; 3.附上AC代码 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define maxn 1000005using namespace std;int t;int a[maxn];int n,m; int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) cin&gt;&gt;a[i]; int lmi=0,lmx=0; for(int i=1;i&lt;=m;i++) &#123; lmi=max(lmi,min(a[i],n-a[i])); lmx=max(lmx,max(a[i],n-a[i])); &#125; cout&lt;&lt;lmi&lt;&lt;" "&lt;&lt;lmx&lt;&lt;endl; &#125; while(1) cout&lt;&lt;"Sabrina"&lt;&lt;endl;//防copy return 0;&#125; P1367题目描述有许多蚂蚁在一根无限长的木棍上，每一只蚂蚁都有一个初始位置和初始朝向（任意两只蚂蚁的初始位置不同）。蚂蚁们以每秒一个单位的速度向前移动，当两只蚂蚁相遇时，它们会掉头（掉头时间忽略不计）。现给出每只蚂蚁的初始位置和初始朝向，请你计算出它们在t秒后的位置和朝向。 输入格式第一行，两个空格隔开的整数n，t（代表蚂蚁数n和时间t） 第2~n+1行每行两个整数，第i+1行代表第i只蚂蚁的初始位置ai（ai的绝对值在1000000以内）及初始朝向bi（bi=1时蚂蚁朝右，bi=-1时蚂蚁朝左） 输出格式n行，每行两个整数，第i行代表t秒后第i只蚂蚁的位置及朝向（-1表示朝左，1表示朝右，0表示正在转向中） 输入输出样例输入 #1 复制4 11 15 13 -110 1输出 #1 复制2 06 12 011 1说明/提示【数据范围】 对于40%的数据，n&lt;=100 对于80%的数据，n&lt;=10000,t&lt;=1000 对于100%的数据，n&lt;=100000,t&lt;=100000 题解1.算法思想此题相对而言就要稍微复杂一些，可以称其为升级版。 整体思路看到本题，很明显，经过上一道题的练习，我们很容易想到只管初末状态，在更换灵魂的时候只需要换一下数组下标，最后直接输出就好 具体实现1.因为关于一个下标，我们有两个数据（方向，位置）来存储，所以显然需要开一个结构体。其次，因为要把时间复杂度控制在线性上面，所以显然需要预处理，也就是按输入的位置来排序2.其次，我们需要另开一个结构体数组来存贮之后的状态3.在对下标的处理中，我们需要另开一个数组来改变下标对蚂蚁的映射关系，使输出的序列满足从小到大4.可能有人还比较模糊，看代码5.附上AC代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define maxn 10005using namespace std;struct node&#123; int s;//存位置 int h;//存方向 int num;//存下标&#125;q[maxn],p[maxn];//q用来保存初状态，p用来保存末状态bool cmp(node x,node y)&#123; return x.s&lt;y.s;&#125; int n,t;int a,b; int order[maxn];//改变的映射关系int main()&#123; cin&gt;&gt;n&gt;&gt;t; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; q[i].s=a; q[i].h=b; q[i].num=i; p[i].s=a+b*t;//t的正负代表了向右还是向左 p[i].num=0;//对于p数组是用来通过order的映射输出的所以不需要 p[i].h=b; &#125; sort(q+1,q+1+n,cmp);//预处理 for(int i=1;i&lt;=n;i++) &#123; order[q[i].num]=i;//从左到右的蚂蚁编号映射成现在sort后对应的下标 &#125; sort(p+1,p+1+n,cmp);//同样，将蚂蚁按从左到右排列 for(int i=1;i&lt;=n;i++) &#123; if(p[i].s==p[i+1].s)//这个是用来考虑判断是否正在经历相遇转向的过程 &#123; p[i].h=0; p[i+1].h=0; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; int g=order[i]; //再通过映射关系，获得根据输入数据而获得的标号，实现相遇时的反向，交换，下面有一波打表 //大概就是说第i个输入的数现在在第几个位置上 cout&lt;&lt;p[g].s&lt;&lt;" "&lt;&lt;p[g].h&lt;&lt;endl; &#125; return 0;&#125; n=3； t=2； q[1].s=3;q[1].num=1;q[1].h=-1; q[2].s=2;q[2].num=2;q[1].h=1; q[3].s=1;q[3].num=3;q[3].h=1; p[1].s=1;p[1].h=-1; p[2].s=4;p[2].h=1; p[3].s=3;p[3].h=1; sort1: q[1].num=3;q[2].num=2;q[3].num=1; order[1]=3;order[2]=2;order[3]=1; sort2: p[1].s=1;p[2].s=3;p[3].s=4; for: i=1:g=3; i=2:g=2; i=3:g=1;]]></content>
      <tags>
        <tag>7-26 only for S.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSP旅行商问题-位运算-Sabrina-Sabrinadol]]></title>
    <url>%2F2019%2F07%2F25%2FTSP%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98-%E4%BD%8D%E8%BF%90%E7%AE%97-Sabrina-Sabrinadol%2F</url>
    <content type="text"><![CDATA[TSP问题 (tsp.cpp/c/pas) Time Limit : 1 sec ， Memory Limit : 128MB Description 对于给定的加权有向图G(V,E)，查找满足以下条件的最短路径的距离:  这条路径是一个环，即这条路径的起点和终点都是同一个点。  每个顶点只能访问一次。 Input |V| |E| s0 t0 d0 s1 t1 d1 : s|E|−1 t|E|−1 d|E|−1 |V| 是顶点数，|E|是边数。顶点以数字 0, 1,…, |V|-1表示。 si 和ti 表示第i条边(有向)的源和目标顶点，di 表示si和 ti (第i条边)之间的距离。 Output 在一行中输出最短距离。如果没有解决方案，则输出 -1。 Constraints  2 ≤ |V| ≤ 15  0 ≤ di ≤ 1,000  没有多重边Sample Input 1 4 6 0 1 2 1 2 3 1 3 9 2 0 1 2 3 6 3 2 4 Sample Output 1 16Sample Input 2 3 3 0 1 1 1 2 1 0 2 1 Sample Output 2 -1 题解1.首先看到本题，绝大多数人的想法都是DFS，虽然时间复杂度有点高，但是一看数据，又不太，只要我们在深搜中加上记忆化处理，顺便剪一剪枝，也是可以过的 但是！！我想说的不是DFS，而是带上动规的思想。 如下（1）（实现需要使用位运算，等会说）首先假设出一个dp[s][k],s代表已经被扫到的元素的集合，k代表刚进入集合，这里我们是不是就需要列出和k相连的元素（i），然后判定该元素是否已经属于该集合，如果不，就向下扫取最小值动规方程：dp[s][i]=min{dp[s+i][i]+d[k][i]}//d数组存储的是图（2）边界处理1.记忆化处理，当我们扫到的dp值大于0的时候，说明该点已经被扫过了，直接返回值就好2.当扫到初始点的时候，直接返回dp=0就好了（3）元素属于判断以及判断是否扫完每一个元素首先我们知道每种元素只有在集合中和不在集合中两种状态，所以我们可以依靠二进制位运算来表示每个元素的状态，0为不在，1为在 插入：位运算-其实一共就是五种通过二进制位来实现1.&amp;：与 两个二进制位都为1才12.|：或 两个二进制位只要有一个为1就为13.^:异或 相同为1，相反为04.&lt;&lt;左移 将整个数的二进制位左移 右补0 左舍5.&gt;&gt; 右移 溢出补0 左补0 右舍这篇文章写得通俗易懂 （4）代码，有详细注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define maxn 99999using namespace std; int moving[1&lt;&lt;16][100];int a[1000][1000];int b,c,d;int n,m;int search(int s,int k)&#123; if(moving[s][k]&gt;=0) //这里就是上面所说的记忆化 return moving[s][k]; if(s==(1&lt;&lt;n)-1&amp;&amp;k==0)//如果s已满那么加一就会进位到2的n次方，k等于代表回到起点 return moving[s][k]=0;//已经回到了，不再有值 int num=9999; for(int i=0;i&lt;n;i++) &#123; if(!(s&gt;&gt;i&amp;1))//先判定i点是否加入了集合 &#123; num=min(num,search(s|1&lt;&lt;i,i)+a[k][i]); //如果没加入集合就取小，这里因为我们将a数组初始化得大于最大值，所以不用考虑能否到达 &#125; &#125; return moving[s][k]=num;&#125;int main()&#123; //freopen("tsp.in","r",stdin); //freopen("tsp.out","w",stdout); memset(moving,-1,sizeof(moving)); memset(a,0x3f,sizeof(a)); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;b&gt;&gt;c&gt;&gt;d; a[b][c]=d; &#125; long long int kk=search(0,0); if(kk==9999||kk&lt;0) cout&lt;&lt;"-1";//如果值未更新的话，就相当没有找到 else cout&lt;&lt;kk; while(1) cout&lt;&lt;"by Sabrinadol"&lt;&lt;endl;//防copy fclose(stdin); fclose(stdout); return 0;&#125; –Sabrinadol]]></content>
  </entry>
  <entry>
    <title><![CDATA[数学筛法--很全--在noip中的运用]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%95%B0%E5%AD%A6%E7%AD%9B%E6%B3%95-%E5%BE%88%E5%85%A8-%E5%9C%A8noip%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#1.求素数用到的方法 ####（1）普通枚举 枚举到sqrt（n）就好 ####（2）朴素筛法通过对每个数有无非平凡因子来判断朴素筛法 nlogn ，这个时间复杂度的计算有些复杂如下n/2+n/3+n/4+…..+n/n;n(1/2+1/3+1/4+….+1/n)后面那一坨大致就约等于 ln（n） （学过数竞应该知道） 12345678910111213int a[maxn],b[maxn],n;int cnt=0;//筛出 2 到 n 中的所有素数 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//从i+i往后筛所有的倍数 a[j]=1; &#125;&#125; ####（3）埃式筛法通过素因子来筛 123456789101112131415int a[maxn],b[maxn],n;int cnt=0;//优化， nloglogn ，这里的计算跟上个差不多，埃式筛法 void naive_sieve(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) &#123; b[cnt++]=i; for(int j=2*i;j&lt;=n;j+=i)//将此循环体拿到if依据里面 //意思就是，在遍历筛的时候遇到的如果是合数就不用筛了，优化 a[j]=1; &#125; &#125;&#125; ####（4）线性筛（欧拉筛） 123456789101112131415void oula_sieve(int n)&#123; int cnt=0; for(int i=2;i&lt;=n;i++) &#123; if(!a[i]) b[cnt++]=a[i]; for(int j=0;b[j]*i&lt;=n;j++) &#123; a[b[j]*i]=1;// 保证b[j]是i*b[j]1的最小素因子 if(i%b[j]==0) break; &#125; &#125;&#125; 大家可能对以上三种方法及其优化思路还有疑问，下面加深讲解1.基本思想其实都是先筛掉有非平凡因数的合数筛掉，再进行存储2.举下面 一个栗子比如说我们要筛 12这个数（1）朴素筛 ： 除1外每个数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 ： 2 3 4 6（2）埃氏筛 ： 除1外每个质因数都要去把12筛一遍也就是我们扫到这些数都要去把12筛 : 2 3 （3）欧拉筛 ：可能有人不太懂1–j代表的是下标2–b[]存储找到的素数代码中的第二重（if依据巧妙避开求重）可以让标记只让当前找到的素因数往后标记3–还是举12的例子12的最小质因数会将12筛出也就是只有：2 ###4–总结欧拉筛：每次用已筛出来的质数去筛更大的数，每个合数只被它最小的质因子筛掉，试想，如果26筛了12之后还没break，而是用36筛掉18，那么18还会被29筛一次，就重复了而根本原因就是6有2这个因子，而36筛掉的数一定也有2这个因子，3*6这个数应该被2这个因子筛掉，而不是3]]></content>
  </entry>
  <entry>
    <title><![CDATA[Newpost]]></title>
    <url>%2F2019%2F07%2F24%2FNewpost%2F</url>
    <content type="text"><![CDATA[Hi]]></content>
  </entry>
  <entry>
    <title><![CDATA[拓朴排序]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%8B%93%E6%9C%B4%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.什么是拓扑排序呢拓扑排序是指将将要做的事情先进行排序，在处理时按照顺序处理。]]></content>
      <categories>
        <category>NOIPLearning</category>
      </categories>
  </entry>
</search>
